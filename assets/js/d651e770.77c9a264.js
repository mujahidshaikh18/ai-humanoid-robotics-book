"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[430],{2241:(e,r,n)=>{n.r(r),n.d(r,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>t,metadata:()=>c,toc:()=>o});var i=n(4848),s=n(8453);const t={sidebar_position:2,title:"Chapter 2: ROS 2 Core Architecture"},a="ROS 2 Core Architecture",c={id:"module-1/chapter-2",title:"Chapter 2: ROS 2 Core Architecture",description:"Overview",source:"@site/docs/module-1/chapter-2.mdx",sourceDirName:"module-1",slug:"/module-1/chapter-2",permalink:"/ai-humanoid-robotics-book/docs/module-1/chapter-2",draft:!1,unlisted:!1,editUrl:"https://github.com/mujahidshaikh18/ai-humanoid-robotics-book/tree/main/docs/module-1/chapter-2.mdx",tags:[],version:"current",sidebarPosition:2,frontMatter:{sidebar_position:2,title:"Chapter 2: ROS 2 Core Architecture"},sidebar:"tutorialSidebar",previous:{title:"Chapter 1: Introduction to Physical AI & ROS 2",permalink:"/ai-humanoid-robotics-book/docs/module-1/chapter-1"},next:{title:"Chapter 3: Building ROS 2 Packages in Python",permalink:"/ai-humanoid-robotics-book/docs/module-1/chapter-3"}},l={},o=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Architecture Overview",id:"architecture-overview",level:2},{value:"The ROS 2 Stack",id:"the-ros-2-stack",level:3},{value:"DDS (Data Distribution Service)",id:"dds-data-distribution-service",level:2},{value:"Key Features of DDS",id:"key-features-of-dds",level:3},{value:"QoS Policies",id:"qos-policies",level:3},{value:"Communication Patterns",id:"communication-patterns",level:2},{value:"Topics (Publish-Subscribe)",id:"topics-publish-subscribe",level:3},{value:"Services (Request-Reply)",id:"services-request-reply",level:3},{value:"Actions (Long-Running Tasks)",id:"actions-long-running-tasks",level:3},{value:"Nodes and Processes",id:"nodes-and-processes",level:2},{value:"Node Lifecycle",id:"node-lifecycle",level:3},{value:"Parameters",id:"parameters",level:2},{value:"Launch Files",id:"launch-files",level:2},{value:"Summary",id:"summary",level:2}];function d(e){const r={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(r.h1,{id:"ros-2-core-architecture",children:"ROS 2 Core Architecture"}),"\n",(0,i.jsx)(r.h2,{id:"overview",children:"Overview"}),"\n",(0,i.jsx)(r.p,{children:"This chapter delves into the fundamental architecture of ROS 2, exploring its design principles, communication mechanisms, and system organization. Understanding the core architecture is essential for building robust robotic applications."}),"\n",(0,i.jsx)(r.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,i.jsx)(r.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,i.jsxs)(r.ul,{children:["\n",(0,i.jsx)(r.li,{children:"Describe the key architectural components of ROS 2"}),"\n",(0,i.jsx)(r.li,{children:"Explain the communication patterns in ROS 2 (topics, services, actions)"}),"\n",(0,i.jsx)(r.li,{children:"Understand the role of DDS in ROS 2 communication"}),"\n",(0,i.jsx)(r.li,{children:"Implement basic communication patterns in ROS 2"}),"\n"]}),"\n",(0,i.jsx)(r.h2,{id:"architecture-overview",children:"Architecture Overview"}),"\n",(0,i.jsx)(r.p,{children:"ROS 2 follows a distributed architecture where multiple processes (nodes) communicate with each other over a network. The architecture is built on top of DDS (Data Distribution Service), which provides the underlying communication infrastructure."}),"\n",(0,i.jsx)(r.h3,{id:"the-ros-2-stack",children:"The ROS 2 Stack"}),"\n",(0,i.jsx)(r.p,{children:"The ROS 2 stack consists of several layers:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Application   \u2502  \u2190 User applications and nodes\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   ROS 2 Client  \u2502  \u2190 rclcpp, rclpy, etc.\r\n\u2502   Libraries (rcl)\u2502\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   DDS Abstraction\u2502 \u2190 rmw (ROS Middleware)\r\n\u251c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2524\r\n\u2502   DDS Implementation\u2502 \u2190 Fast DDS, Cyclone DDS, etc.\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,i.jsx)(r.h2,{id:"dds-data-distribution-service",children:"DDS (Data Distribution Service)"}),"\n",(0,i.jsx)(r.p,{children:"DDS is the middleware that ROS 2 uses for communication. It provides a publish-subscribe communication model with quality of service (QoS) settings."}),"\n",(0,i.jsx)(r.h3,{id:"key-features-of-dds",children:"Key Features of DDS"}),"\n",(0,i.jsxs)(r.ol,{children:["\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Data-Centric"}),": Focuses on data rather than communication endpoints"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Quality of Service (QoS)"}),": Configurable policies for reliability, durability, etc."]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Discovery"}),": Automatic discovery of publishers and subscribers"]}),"\n",(0,i.jsxs)(r.li,{children:[(0,i.jsx)(r.strong,{children:"Real-time Support"}),": Designed for real-time applications"]}),"\n"]}),"\n",(0,i.jsx)(r.h3,{id:"qos-policies",children:"QoS Policies"}),"\n",(0,i.jsx)(r.p,{children:"ROS 2 provides several QoS policies that control communication behavior:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"from rclpy.qos import QoSProfile, ReliabilityPolicy, HistoryPolicy\r\n\r\n# Create a QoS profile for reliable communication\r\nqos_profile = QoSProfile(\r\n    depth=10,  # Number of messages to queue\r\n    reliability=ReliabilityPolicy.RELIABLE,  # Ensure all messages are delivered\r\n    history=HistoryPolicy.KEEP_LAST  # Keep only the last N messages\r\n)\n"})}),"\n",(0,i.jsx)(r.h2,{id:"communication-patterns",children:"Communication Patterns"}),"\n",(0,i.jsx)(r.h3,{id:"topics-publish-subscribe",children:"Topics (Publish-Subscribe)"}),"\n",(0,i.jsx)(r.p,{children:"Topics implement a publish-subscribe communication pattern where publishers send messages to topics and subscribers receive messages from topics."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import String\r\n\r\nclass Talker(Node):\r\n    def __init__(self):\r\n        super().__init__('talker')\r\n        self.publisher = self.create_publisher(String, 'chatter', 10)\r\n        timer_period = 0.5\r\n        self.timer = self.create_timer(timer_period, self.timer_callback)\r\n\r\n    def timer_callback(self):\r\n        msg = String()\r\n        msg.data = 'Hello ROS 2 World'\r\n        self.publisher.publish(msg)\r\n        self.get_logger().info(f'Publishing: {msg.data}')\r\n\r\nclass Listener(Node):\r\n    def __init__(self):\r\n        super().__init__('listener')\r\n        self.subscription = self.create_subscription(\r\n            String,\r\n            'chatter',\r\n            self.listener_callback,\r\n            10)\r\n        self.subscription  # Prevent unused variable warning\r\n\r\n    def listener_callback(self, msg):\r\n        self.get_logger().info(f'I heard: {msg.data}')\n"})}),"\n",(0,i.jsx)(r.h3,{id:"services-request-reply",children:"Services (Request-Reply)"}),"\n",(0,i.jsx)(r.p,{children:"Services provide synchronous request-reply communication between nodes."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.srv import AddTwoInts\r\n\r\nclass MinimalService(Node):\r\n    def __init__(self):\r\n        super().__init__('minimal_service')\r\n        self.srv = self.create_service(AddTwoInts, 'add_two_ints', self.add_two_ints_callback)\r\n\r\n    def add_two_ints_callback(self, request, response):\r\n        response.sum = request.a + request.b\r\n        self.get_logger().info(f'Returning {request.a} + {request.b} = {response.sum}')\r\n        return response\r\n\r\ndef main():\r\n    rclpy.init()\r\n    minimal_service = MinimalService()\r\n    rclpy.spin(minimal_service)\r\n    rclpy.shutdown()\n"})}),"\n",(0,i.jsx)(r.h3,{id:"actions-long-running-tasks",children:"Actions (Long-Running Tasks)"}),"\n",(0,i.jsx)(r.p,{children:"Actions are designed for long-running tasks that may provide feedback and can be canceled."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.action import ActionServer\r\nfrom rclpy.node import Node\r\nfrom example_interfaces.action import Fibonacci\r\n\r\nclass FibonacciActionServer(Node):\r\n    def __init__(self):\r\n        super().__init__('fibonacci_action_server')\r\n        self._action_server = ActionServer(\r\n            self,\r\n            Fibonacci,\r\n            'fibonacci',\r\n            self.execute_callback)\r\n\r\n    def execute_callback(self, goal_handle):\r\n        self.get_logger().info('Executing goal...')\r\n\r\n        feedback_msg = Fibonacci.Feedback()\r\n        feedback_msg.sequence = [0, 1]\r\n\r\n        for i in range(1, goal_handle.request.order):\r\n            feedback_msg.sequence.append(\r\n                feedback_msg.sequence[i] + feedback_msg.sequence[i-1])\r\n\r\n            self.get_logger().info(f'Feedback: {feedback_msg.sequence}')\r\n            goal_handle.publish_feedback(feedback_msg)\r\n\r\n        goal_handle.succeed()\r\n        result = Fibonacci.Result()\r\n        result.sequence = feedback_msg.sequence\r\n        return result\n"})}),"\n",(0,i.jsx)(r.h2,{id:"nodes-and-processes",children:"Nodes and Processes"}),"\n",(0,i.jsx)(r.p,{children:"In ROS 2, nodes are individual processes that perform computation. Multiple nodes can run on the same machine or be distributed across multiple machines."}),"\n",(0,i.jsx)(r.h3,{id:"node-lifecycle",children:"Node Lifecycle"}),"\n",(0,i.jsx)(r.p,{children:"Nodes in ROS 2 follow a specific lifecycle:"}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"from lifecycle_py.lifecycle_node import LifecycleNode\r\nfrom lifecycle_msgs.msg import State\r\n\r\nclass LifecycleTalker(LifecycleNode):\r\n    def __init__(self):\r\n        super().__init__('lifecycle_talker')\r\n\r\n    def on_configure(self, state):\r\n        self.get_logger().info(f'Configuring node: {state}')\r\n        # Create publisher but don't allow publishing yet\r\n        self.pub = self.create_publisher(String, 'chatter', 10)\r\n        return super().on_configure(state)\r\n\r\n    def on_activate(self, state):\r\n        self.get_logger().info(f'Activating node: {state}')\r\n        # Now we can publish messages\r\n        return super().on_activate(state)\n"})}),"\n",(0,i.jsx)(r.h2,{id:"parameters",children:"Parameters"}),"\n",(0,i.jsx)(r.p,{children:"Parameters in ROS 2 allow for configuration of nodes at runtime."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"class ParameterNode(Node):\r\n    def __init__(self):\r\n        super().__init__('parameter_node')\r\n\r\n        # Declare a parameter with a default value\r\n        self.declare_parameter('my_parameter', 'default_value')\r\n\r\n        # Get the parameter value\r\n        param_value = self.get_parameter('my_parameter').value\r\n        self.get_logger().info(f'Parameter value: {param_value}')\r\n\r\n        # Create a callback for parameter changes\r\n        self.add_on_set_parameters_callback(self.parameter_callback)\r\n\r\n    def parameter_callback(self, params):\r\n        for param in params:\r\n            if param.name == 'my_parameter':\r\n                self.get_logger().info(f'Parameter changed to: {param.value}')\r\n        return SetParametersResult(successful=True)\n"})}),"\n",(0,i.jsx)(r.h2,{id:"launch-files",children:"Launch Files"}),"\n",(0,i.jsx)(r.p,{children:"Launch files allow you to start multiple nodes with a single command."}),"\n",(0,i.jsx)(r.pre,{children:(0,i.jsx)(r.code,{className:"language-python",children:"from launch import LaunchDescription\r\nfrom launch_ros.actions import Node\r\n\r\ndef generate_launch_description():\r\n    return LaunchDescription([\r\n        Node(\r\n            package='demo_nodes_py',\r\n            executable='talker',\r\n            name='talker',\r\n        ),\r\n        Node(\r\n            package='demo_nodes_py',\r\n            executable='listener',\r\n            name='listener',\r\n        ),\r\n    ])\n"})}),"\n",(0,i.jsx)(r.h2,{id:"summary",children:"Summary"}),"\n",(0,i.jsx)(r.p,{children:"This chapter covered the core architecture of ROS 2, including its communication patterns, DDS middleware, and system organization. Understanding these concepts is crucial for building effective robotic applications with ROS 2."}),"\n",(0,i.jsx)(r.p,{children:"In the next chapter, we'll explore building ROS 2 packages in Python, where we'll put these architectural concepts into practice."})]})}function u(e={}){const{wrapper:r}={...(0,s.R)(),...e.components};return r?(0,i.jsx)(r,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},8453:(e,r,n)=>{n.d(r,{R:()=>a,x:()=>c});var i=n(6540);const s={},t=i.createContext(s);function a(e){const r=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(r):{...r,...e}},[r,e])}function c(e){let r;return r=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:a(e.components),i.createElement(t.Provider,{value:r},e.children)}}}]);