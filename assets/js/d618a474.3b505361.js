"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[280],{4891:(n,e,i)=>{i.r(e),i.d(e,{assets:()=>l,contentTitle:()=>a,default:()=>m,frontMatter:()=>o,metadata:()=>t,toc:()=>c});var r=i(4848),s=i(8453);const o={sidebar_position:7,title:"Chapter 7: Gazebo for Humanoid Physics"},a="Gazebo for Humanoid Physics",t={id:"module-2/chapter-7",title:"Chapter 7: Gazebo for Humanoid Physics",description:"Overview",source:"@site/docs/module-2/chapter-7.mdx",sourceDirName:"module-2",slug:"/module-2/chapter-7",permalink:"/ai-humanoid-robotics-book/docs/module-2/chapter-7",draft:!1,unlisted:!1,editUrl:"https://github.com/mujahidshaikh18/ai-humanoid-robotics-book/tree/main/docs/module-2/chapter-7.mdx",tags:[],version:"current",sidebarPosition:7,frontMatter:{sidebar_position:7,title:"Chapter 7: Gazebo for Humanoid Physics"},sidebar:"tutorialSidebar",previous:{title:"Chapter 6: The Digital Twin Concept",permalink:"/ai-humanoid-robotics-book/docs/module-2/chapter-6"},next:{title:"Chapter 8: Sensor Simulation",permalink:"/ai-humanoid-robotics-book/docs/module-2/chapter-8"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Gazebo",id:"introduction-to-gazebo",level:2},{value:"Key Features of Gazebo",id:"key-features-of-gazebo",level:3},{value:"Gazebo Architecture",id:"gazebo-architecture",level:3},{value:"Physics Engines in Gazebo",id:"physics-engines-in-gazebo",level:2},{value:"ODE (Open Dynamics Engine)",id:"ode-open-dynamics-engine",level:3},{value:"Bullet",id:"bullet",level:3},{value:"DART (Dynamic Animation and Robotics Toolkit)",id:"dart-dynamic-animation-and-robotics-toolkit",level:3},{value:"Simbody",id:"simbody",level:3},{value:"Setting Up Gazebo for Humanoid Simulation",id:"setting-up-gazebo-for-humanoid-simulation",level:2},{value:"Installation and Configuration",id:"installation-and-configuration",level:3},{value:"Basic Gazebo Launch File",id:"basic-gazebo-launch-file",level:3},{value:"Physics Configuration for Humanoid Robots",id:"physics-configuration-for-humanoid-robots",level:2},{value:"World File Configuration",id:"world-file-configuration",level:3},{value:"Physics Parameters Explained",id:"physics-parameters-explained",level:3},{value:"Humanoid-Specific Physics Considerations",id:"humanoid-specific-physics-considerations",level:2},{value:"Center of Mass and Stability",id:"center-of-mass-and-stability",level:3},{value:"Joint Dynamics and Actuator Models",id:"joint-dynamics-and-actuator-models",level:3},{value:"Gazebo Plugins for Humanoid Robots",id:"gazebo-plugins-for-humanoid-robots",level:2},{value:"Joint Control Plugins",id:"joint-control-plugins",level:3},{value:"Position Control Plugin",id:"position-control-plugin",level:4},{value:"Individual Joint Controllers",id:"individual-joint-controllers",level:4},{value:"Sensor Plugins",id:"sensor-plugins",level:3},{value:"IMU Sensor",id:"imu-sensor",level:4},{value:"Force/Torque Sensors",id:"forcetorque-sensors",level:4},{value:"ROS 2 Integration",id:"ros-2-integration",level:2},{value:"Robot State Publisher in Simulation",id:"robot-state-publisher-in-simulation",level:3},{value:"Control Interface",id:"control-interface",level:3},{value:"Physics Tuning for Humanoid Simulation",id:"physics-tuning-for-humanoid-simulation",level:2},{value:"Stability Considerations",id:"stability-considerations",level:3},{value:"Time Step Selection",id:"time-step-selection",level:4},{value:"Contact Parameters",id:"contact-parameters",level:4},{value:"Mass Distribution",id:"mass-distribution",level:3},{value:"Advanced Gazebo Features for Humanoids",id:"advanced-gazebo-features-for-humanoids",level:2},{value:"Custom Physics Plugins",id:"custom-physics-plugins",level:3},{value:"Terrain and Environment Simulation",id:"terrain-and-environment-simulation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Simulation Performance Tips",id:"simulation-performance-tips",level:3},{value:"Parallel Processing",id:"parallel-processing",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Instability Problems",id:"instability-problems",level:3},{value:"Penetration Issues",id:"penetration-issues",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",h4:"h4",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,s.R)(),...n.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(e.h1,{id:"gazebo-for-humanoid-physics",children:"Gazebo for Humanoid Physics"}),"\n",(0,r.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo is a powerful 3D simulation environment that provides accurate physics simulation for robotics applications. For humanoid robots, Gazebo offers sophisticated physics modeling capabilities that are essential for realistic simulation of complex multi-joint systems with intricate kinematics and dynamics."}),"\n",(0,r.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,r.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Configure Gazebo for humanoid robot simulation"}),"\n",(0,r.jsx)(e.li,{children:"Understand physics engines and their parameters"}),"\n",(0,r.jsx)(e.li,{children:"Implement realistic humanoid physics models"}),"\n",(0,r.jsx)(e.li,{children:"Tune simulation parameters for accuracy"}),"\n",(0,r.jsx)(e.li,{children:"Integrate Gazebo with ROS 2 for humanoid control"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"introduction-to-gazebo",children:"Introduction to Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo is an open-source robotics simulator that provides high-fidelity physics simulation, realistic rendering, and convenient programmatic interfaces. It's widely used in robotics research and development for testing algorithms, training AI models, and validating robot designs before deployment on physical hardware."}),"\n",(0,r.jsx)(e.h3,{id:"key-features-of-gazebo",children:"Key Features of Gazebo"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Physics Simulation"}),": Accurate modeling of rigid body dynamics"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Sensor Simulation"}),": Realistic simulation of various robot sensors"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Rendering"}),": High-quality 3D visualization with OpenGL"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Plugins"}),": Extensible architecture for custom functionality"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ROS Integration"}),": Seamless integration with ROS and ROS 2"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"gazebo-architecture",children:"Gazebo Architecture"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   GUI Client   \u2502    \u2502   Server        \u2502    \u2502   Physics       \u2502\r\n\u2502   (gzclient)   \u2502\u25c4\u2500\u2500\u25ba\u2502   (gzserver)    \u2502\u25c4\u2500\u2500\u25ba\u2502   Engine        \u2502\r\n\u2502                \u2502    \u2502                 \u2502    \u2502   (ODE, Bullet, \u2502\r\n\u2502 - Visualization\u2502    \u2502 - World         \u2502    \u2502   DART, Simbody)\u2502\r\n\u2502 - Controls     \u2502    \u2502 - Models        \u2502    \u2502                 \u2502\r\n\u2502 - Plugins      \u2502    \u2502 - Sensors       \u2502    \u2502                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,r.jsx)(e.h2,{id:"physics-engines-in-gazebo",children:"Physics Engines in Gazebo"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo supports multiple physics engines, each with different characteristics:"}),"\n",(0,r.jsx)(e.h3,{id:"ode-open-dynamics-engine",children:"ODE (Open Dynamics Engine)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Default physics engine for Gazebo"}),"\n",(0,r.jsx)(e.li,{children:"Good performance for most applications"}),"\n",(0,r.jsx)(e.li,{children:"Stable for rigid body simulations"}),"\n",(0,r.jsx)(e.li,{children:"Well-tested and mature"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"bullet",children:"Bullet"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Fast and robust physics engine"}),"\n",(0,r.jsx)(e.li,{children:"Good for complex contact scenarios"}),"\n",(0,r.jsx)(e.li,{children:"Supports soft body simulation"}),"\n",(0,r.jsx)(e.li,{children:"Used in many game engines"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"dart-dynamic-animation-and-robotics-toolkit",children:"DART (Dynamic Animation and Robotics Toolkit)"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Advanced dynamics and kinematics"}),"\n",(0,r.jsx)(e.li,{children:"Better for complex articulated systems"}),"\n",(0,r.jsx)(e.li,{children:"Supports hybrid dynamics"}),"\n",(0,r.jsx)(e.li,{children:"Good for humanoid robots"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"simbody",children:"Simbody"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multibody dynamics engine"}),"\n",(0,r.jsx)(e.li,{children:"High accuracy for complex systems"}),"\n",(0,r.jsx)(e.li,{children:"Good for biomechanical simulations"}),"\n",(0,r.jsx)(e.li,{children:"Less commonly used"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"setting-up-gazebo-for-humanoid-simulation",children:"Setting Up Gazebo for Humanoid Simulation"}),"\n",(0,r.jsx)(e.h3,{id:"installation-and-configuration",children:"Installation and Configuration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-bash",children:"# Install Gazebo (Harmonic version for ROS 2 Humble)\r\nsudo apt install ros-humble-gazebo-ros-pkgs\r\n\r\n# Or for other ROS 2 versions\r\nsudo apt install ros-<ros2-distro>-gazebo-ros-pkgs\n"})}),"\n",(0,r.jsx)(e.h3,{id:"basic-gazebo-launch-file",children:"Basic Gazebo Launch File"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0"?>\r\n<launch>\r\n  \x3c!-- Start Gazebo with empty world --\x3e\r\n  <include file="$(find gazebo_ros)/launch/empty_world.launch.py">\r\n    <arg name="world" value="$(find my_robot_description)/worlds/my_world.world"/>\r\n    <arg name="paused" value="false"/>\r\n    <arg name="use_sim_time" value="true"/>\r\n    <arg name="gui" value="true"/>\r\n    <arg name="headless" value="false"/>\r\n    <arg name="debug" value="false"/>\r\n  </include>\r\n\r\n  \x3c!-- Spawn robot in Gazebo --\x3e\r\n  <node name="spawn_urdf" pkg="gazebo_ros" type="spawn_entity.py"\r\n        args="-entity my_humanoid -file $(find my_robot_description)/urdf/my_humanoid.urdf"\r\n        output="screen"/>\r\n</launch>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"physics-configuration-for-humanoid-robots",children:"Physics Configuration for Humanoid Robots"}),"\n",(0,r.jsx)(e.h3,{id:"world-file-configuration",children:"World File Configuration"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<?xml version="1.0" ?>\r\n<sdf version="1.7">\r\n  <world name="humanoid_world">\r\n    \x3c!-- Physics engine configuration --\x3e\r\n    <physics name="1ms" type="ode">\r\n      <max_step_size>0.001</max_step_size>\r\n      <real_time_factor>1.0</real_time_factor>\r\n      <real_time_update_rate>1000</real_time_update_rate>\r\n      <gravity>0 0 -9.8</gravity>\r\n\r\n      \x3c!-- ODE-specific parameters --\x3e\r\n      <ode>\r\n        <solver>\r\n          <type>quick</type>\r\n          <iters>10</iters>\r\n          <sor>1.3</sor>\r\n        </solver>\r\n        <constraints>\r\n          <cfm>0.0</cfm>\r\n          <erp>0.2</erp>\r\n          <contact_max_correcting_vel>100.0</contact_max_correcting_vel>\r\n          <contact_surface_layer>0.001</contact_surface_layer>\r\n        </constraints>\r\n      </ode>\r\n    </physics>\r\n\r\n    \x3c!-- Include ground plane --\x3e\r\n    <include>\r\n      <uri>model://ground_plane</uri>\r\n    </include>\r\n\r\n    \x3c!-- Include sun --\x3e\r\n    <include>\r\n      <uri>model://sun</uri>\r\n    </include>\r\n  </world>\r\n</sdf>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"physics-parameters-explained",children:"Physics Parameters Explained"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"max_step_size"}),": Simulation time step (smaller = more accurate but slower)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"real_time_factor"}),": Target simulation speed relative to real time"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"real_time_update_rate"}),": Update rate in Hz (1/max_step_size)"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"gravity"}),": Gravitational acceleration vector"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"solver iterations"}),": More iterations = more stable but slower"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"CFM (Constraint Force Mixing)"}),": Constraint stiffness"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"ERP (Error Reduction Parameter)"}),": Error correction rate"]}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"humanoid-specific-physics-considerations",children:"Humanoid-Specific Physics Considerations"}),"\n",(0,r.jsx)(e.h3,{id:"center-of-mass-and-stability",children:"Center of Mass and Stability"}),"\n",(0,r.jsx)(e.p,{children:"For humanoid robots, proper center of mass (CoM) placement is crucial for stable simulation:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<link name="torso">\r\n  <inertial>\r\n    \x3c!-- CoM should be within the support polygon for stability --\x3e\r\n    <origin xyz="0 0 0.1" rpy="0 0 0"/>\r\n    <mass value="10.0"/>\r\n    \x3c!-- Proper inertia tensor for humanoid torso --\x3e\r\n    <inertia ixx="0.5" ixy="0.0" ixz="0.0"\r\n             iyy="0.6" iyz="0.0" izz="0.2"/>\r\n  </inertial>\r\n\r\n  <visual>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <geometry>\r\n      <box size="0.3 0.2 0.5"/>\r\n    </geometry>\r\n  </visual>\r\n\r\n  <collision>\r\n    <origin xyz="0 0 0" rpy="0 0 0"/>\r\n    <geometry>\r\n      <box size="0.3 0.2 0.5"/>\r\n    </geometry>\r\n  </collision>\r\n</link>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"joint-dynamics-and-actuator-models",children:"Joint Dynamics and Actuator Models"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots require realistic joint dynamics modeling:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<joint name="left_hip_pitch" type="revolute">\r\n  <parent link="torso"/>\r\n  <child link="left_thigh"/>\r\n  <origin xyz="0 -0.1 -0.2" rpy="0 0 0"/>\r\n  <axis xyz="1 0 0"/>\r\n  <limit lower="-1.57" upper="1.57" effort="100.0" velocity="3.0"/>\r\n\r\n  \x3c!-- Dynamics parameters for realistic joint behavior --\x3e\r\n  <dynamics damping="5.0" friction="1.0"/>\r\n</joint>\r\n\r\n\x3c!-- Adding transmission for ROS control --\x3e\r\n<transmission name="left_hip_pitch_trans">\r\n  <type>transmission_interface/SimpleTransmission</type>\r\n  <joint name="left_hip_pitch">\r\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\r\n  </joint>\r\n  <actuator name="left_hip_pitch_motor">\r\n    <hardwareInterface>hardware_interface/EffortJointInterface</hardwareInterface>\r\n    <mechanicalReduction>1</mechanicalReduction>\r\n  </actuator>\r\n</transmission>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"gazebo-plugins-for-humanoid-robots",children:"Gazebo Plugins for Humanoid Robots"}),"\n",(0,r.jsx)(e.h3,{id:"joint-control-plugins",children:"Joint Control Plugins"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo provides various plugins for controlling robot joints:"}),"\n",(0,r.jsx)(e.h4,{id:"position-control-plugin",children:"Position Control Plugin"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin name="gazebo_ros_control" filename="libgazebo_ros_control.so">\r\n    <robotNamespace>/my_humanoid</robotNamespace>\r\n    <robotSimType>gazebo_ros_control/DefaultRobotHWSim</robotSimType>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"individual-joint-controllers",children:"Individual Joint Controllers"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin name="left_leg_controller" filename="libgazebo_ros_joint_position.so">\r\n    <robotNamespace>/my_humanoid</robotNamespace>\r\n    <jointName>left_hip_pitch</jointName>\r\n    <topicName>/my_humanoid/left_hip_pitch/command</topicName>\r\n    <updateRate>100.0</updateRate>\r\n    <alwaysOn>true</alwaysOn>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"sensor-plugins",children:"Sensor Plugins"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots typically use various sensors simulated in Gazebo:"}),"\n",(0,r.jsx)(e.h4,{id:"imu-sensor",children:"IMU Sensor"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo reference="torso">\r\n  <sensor name="imu_sensor" type="imu">\r\n    <always_on>true</always_on>\r\n    <update_rate>100</update_rate>\r\n    <visualize>true</visualize>\r\n    <topic>__default_topic__</topic>\r\n    <pose>0 0 0 0 0 0</pose>\r\n  </sensor>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"forcetorque-sensors",children:"Force/Torque Sensors"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'<gazebo>\r\n  <plugin name="ft_sensor" filename="libgazebo_ros_ft_sensor.so">\r\n    <updateRate>100.0</updateRate>\r\n    <topicName>left_foot_force_torque</topicName>\r\n    <jointName>left_ankle_roll</jointName>\r\n  </plugin>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"ros-2-integration",children:"ROS 2 Integration"}),"\n",(0,r.jsx)(e.h3,{id:"robot-state-publisher-in-simulation",children:"Robot State Publisher in Simulation"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom sensor_msgs.msg import JointState\r\nfrom tf2_ros import TransformBroadcaster\r\nfrom geometry_msgs.msg import TransformStamped\r\nimport math\r\n\r\nclass GazeboInterfaceNode(Node):\r\n    def __init__(self):\r\n        super().__init__(\'gazebo_interface\')\r\n\r\n        # Subscribe to Gazebo joint states\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, \'/joint_states\', self.joint_state_callback, 10)\r\n\r\n        # Publish to robot state publisher\r\n        self.joint_state_pub = self.create_publisher(\r\n            JointState, \'/my_humanoid/joint_states\', 10)\r\n\r\n        # TF broadcaster for transforms\r\n        self.tf_broadcaster = TransformBroadcaster(self)\r\n\r\n        self.joint_states = {}\r\n\r\n    def joint_state_callback(self, msg):\r\n        """Receive joint states from Gazebo"""\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.joint_states[name] = msg.position[i]\r\n\r\n        # Publish joint states for robot state publisher\r\n        self.publish_joint_states()\r\n\r\n    def publish_joint_states(self):\r\n        """Publish joint states to robot state publisher"""\r\n        msg = JointState()\r\n        msg.name = list(self.joint_states.keys())\r\n        msg.position = list(self.joint_states.values())\r\n        msg.header.stamp = self.get_clock().now().to_msg()\r\n        msg.header.frame_id = \'base_link\'\r\n\r\n        self.joint_state_pub.publish(msg)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = GazeboInterfaceNode()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,r.jsx)(e.h3,{id:"control-interface",children:"Control Interface"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-python",children:"import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float64MultiArray\r\nfrom sensor_msgs.msg import JointState\r\nimport numpy as np\r\n\r\nclass HumanoidController(Node):\r\n    def __init__(self):\r\n        super().__init__('humanoid_controller')\r\n\r\n        # Publishers for joint commands\r\n        self.joint_cmd_pubs = {}\r\n        joint_names = [\r\n            'left_hip_pitch', 'left_hip_roll', 'left_hip_yaw',\r\n            'left_knee', 'left_ankle_pitch', 'left_ankle_roll',\r\n            'right_hip_pitch', 'right_hip_roll', 'right_hip_yaw',\r\n            'right_knee', 'right_ankle_pitch', 'right_ankle_roll'\r\n        ]\r\n\r\n        for joint_name in joint_names:\r\n            self.joint_cmd_pubs[joint_name] = self.create_publisher(\r\n                Float64MultiArray, f'/my_humanoid/{joint_name}/command', 10)\r\n\r\n        # Subscriber for sensor feedback\r\n        self.joint_state_sub = self.create_subscription(\r\n            JointState, '/my_humanoid/joint_states', self.joint_state_callback, 10)\r\n\r\n        # Walking pattern timer\r\n        self.walk_timer = self.create_timer(0.01, self.walk_step)\r\n\r\n        self.current_joint_states = {}\r\n        self.walk_phase = 0.0\r\n\r\n    def joint_state_callback(self, msg):\r\n        \"\"\"Update current joint states\"\"\"\r\n        for i, name in enumerate(msg.name):\r\n            if i < len(msg.position):\r\n                self.current_joint_states[name] = msg.position[i]\r\n\r\n    def walk_step(self):\r\n        \"\"\"Generate walking pattern commands\"\"\"\r\n        # Simple walking pattern based on phase\r\n        self.walk_phase += 0.01\r\n\r\n        # Generate joint commands for walking\r\n        commands = self.generate_walk_commands(self.walk_phase)\r\n\r\n        # Publish commands\r\n        for joint_name, cmd_value in commands.items():\r\n            if joint_name in self.joint_cmd_pubs:\r\n                msg = Float64MultiArray()\r\n                msg.data = [cmd_value]\r\n                self.joint_cmd_pubs[joint_name].publish(msg)\r\n\r\n    def generate_walk_commands(self, phase):\r\n        \"\"\"Generate walking commands based on phase\"\"\"\r\n        commands = {}\r\n\r\n        # Simple sinusoidal walking pattern\r\n        left_hip_cmd = 0.2 * math.sin(phase)\r\n        right_hip_cmd = 0.2 * math.sin(phase + math.pi)\r\n\r\n        commands['left_hip_pitch'] = left_hip_cmd\r\n        commands['right_hip_pitch'] = right_hip_cmd\r\n\r\n        # Add more sophisticated walking pattern here\r\n        return commands\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n    node = HumanoidController()\r\n\r\n    try:\r\n        rclpy.spin(node)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        node.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == '__main__':\r\n    main()\n"})}),"\n",(0,r.jsx)(e.h2,{id:"physics-tuning-for-humanoid-simulation",children:"Physics Tuning for Humanoid Simulation"}),"\n",(0,r.jsx)(e.h3,{id:"stability-considerations",children:"Stability Considerations"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots are inherently unstable due to their narrow support base. Proper physics tuning is essential:"}),"\n",(0,r.jsx)(e.h4,{id:"time-step-selection",children:"Time Step Selection"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- For stable humanoid simulation, use smaller time steps --\x3e\r\n<physics name="stable_humanoid" type="ode">\r\n  <max_step_size>0.001</max_step_size>  \x3c!-- 1ms time step --\x3e\r\n  <real_time_update_rate>1000</real_time_update_rate>\r\n  <ode>\r\n    <solver>\r\n      <iters>50</iters>  \x3c!-- More iterations for stability --\x3e\r\n      <sor>1.0</sor>\r\n    </solver>\r\n    <constraints>\r\n      <cfm>1e-5</cfm>    \x3c!-- Lower CFM for stiffer constraints --\x3e\r\n      <erp>0.9</erp>     \x3c!-- Higher ERP for faster error correction --\x3e\r\n    </constraints>\r\n  </ode>\r\n</physics>\n'})}),"\n",(0,r.jsx)(e.h4,{id:"contact-parameters",children:"Contact Parameters"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Proper contact parameters for feet --\x3e\r\n<gazebo reference="left_foot">\r\n  <collision>\r\n    <surface>\r\n      <friction>\r\n        <ode>\r\n          <mu>1.0</mu>      \x3c!-- High friction for stable standing --\x3e\r\n          <mu2>1.0</mu2>\r\n        </ode>\r\n      </friction>\r\n      <bounce>\r\n        <restitution_coefficient>0.01</restitution_coefficient>\r\n        <threshold>100</threshold>\r\n      </bounce>\r\n    </surface>\r\n  </collision>\r\n</gazebo>\n'})}),"\n",(0,r.jsx)(e.h3,{id:"mass-distribution",children:"Mass Distribution"}),"\n",(0,r.jsx)(e.p,{children:"Proper mass distribution is critical for humanoid stability:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Example of realistic humanoid mass distribution --\x3e\r\n<link name="head">\r\n  <inertial>\r\n    <mass value="2.0"/>  \x3c!-- Head: ~2kg --\x3e\r\n    <inertia ixx="0.01" ixy="0.0" ixz="0.0"\r\n             iyy="0.01" iyz="0.0" izz="0.01"/>\r\n  </inertial>\r\n</link>\r\n\r\n<link name="torso">\r\n  <inertial>\r\n    <mass value="25.0"/>  \x3c!-- Torso: ~25kg (majority of mass) --\x3e\r\n    <inertia ixx="1.0" ixy="0.0" ixz="0.0"\r\n             iyy="1.2" iyz="0.0" izz="0.5"/>\r\n  </inertial>\r\n</link>\r\n\r\n<link name="upper_arm">\r\n  <inertial>\r\n    <mass value="1.5"/>  \x3c!-- Arms: ~1.5kg each --\x3e\r\n    <inertia ixx="0.01" ixy="0.0" ixz="0.0"\r\n             iyy="0.05" iyz="0.0" izz="0.05"/>\r\n  </inertial>\r\n</link>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"advanced-gazebo-features-for-humanoids",children:"Advanced Gazebo Features for Humanoids"}),"\n",(0,r.jsx)(e.h3,{id:"custom-physics-plugins",children:"Custom Physics Plugins"}),"\n",(0,r.jsx)(e.p,{children:"For advanced humanoid simulation, you can create custom physics plugins:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-cpp",children:"#include <gazebo/gazebo.hh>\r\n#include <gazebo/physics/physics.hh>\r\n#include <gazebo/common/common.hh>\r\n\r\nnamespace gazebo\r\n{\r\n  class HumanoidBalancePlugin : public ModelPlugin\r\n  {\r\n    public: void Load(physics::ModelPtr _model, sdf::ElementPtr _sdf)\r\n    {\r\n      this->model = _model;\r\n      this->world = _model->GetWorld();\r\n\r\n      // Connect to physics update event\r\n      this->updateConnection = event::Events::ConnectWorldUpdateBegin(\r\n          std::bind(&HumanoidBalancePlugin::OnUpdate, this));\r\n    }\r\n\r\n    public: void OnUpdate()\r\n    {\r\n      // Implement balance control logic\r\n      // Access links and joints through this->model\r\n      // Apply forces/torques to maintain balance\r\n    }\r\n\r\n    private: physics::ModelPtr model;\r\n    private: physics::WorldPtr world;\r\n    private: event::ConnectionPtr updateConnection;\r\n  };\r\n\r\n  GZ_REGISTER_MODEL_PLUGIN(HumanoidBalancePlugin)\r\n}\n"})}),"\n",(0,r.jsx)(e.h3,{id:"terrain-and-environment-simulation",children:"Terrain and Environment Simulation"}),"\n",(0,r.jsx)(e.p,{children:"Humanoid robots need to navigate various terrains:"}),"\n",(0,r.jsx)(e.pre,{children:(0,r.jsx)(e.code,{className:"language-xml",children:'\x3c!-- Complex terrain for humanoid testing --\x3e\r\n<world name="humanoid_test_world">\r\n  \x3c!-- Physics --\x3e\r\n  <physics name="default" type="ode">\r\n    <max_step_size>0.001</max_step_size>\r\n    <real_time_factor>1.0</real_time_factor>\r\n  </physics>\r\n\r\n  \x3c!-- Ground plane with texture --\x3e\r\n  <model name="ground_plane">\r\n    <static>true</static>\r\n    <link name="link">\r\n      <collision name="collision">\r\n        <geometry>\r\n          <plane>\r\n            <normal>0 0 1</normal>\r\n            <size>100 100</size>\r\n          </plane>\r\n        </geometry>\r\n      </collision>\r\n      <visual name="visual">\r\n        <geometry>\r\n          <plane>\r\n            <normal>0 0 1</normal>\r\n            <size>100 100</size>\r\n          </plane>\r\n        </geometry>\r\n        <material>\r\n          <script>Gazebo/Grey<\/script>\r\n        </material>\r\n      </visual>\r\n    </link>\r\n  </model>\r\n\r\n  \x3c!-- Obstacles for navigation testing --\x3e\r\n  <model name="step_obstacle">\r\n    <pose>2 0 0.05 0 0 0</pose>\r\n    <link name="link">\r\n      <collision name="collision">\r\n        <geometry>\r\n          <box>\r\n            <size>0.5 2 0.1</size>\r\n          </box>\r\n        </geometry>\r\n      </collision>\r\n      <visual name="visual">\r\n        <geometry>\r\n          <box>\r\n            <size>0.5 2 0.1</size>\r\n          </box>\r\n        </geometry>\r\n      </visual>\r\n    </link>\r\n  </model>\r\n</world>\n'})}),"\n",(0,r.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,r.jsx)(e.h3,{id:"simulation-performance-tips",children:"Simulation Performance Tips"}),"\n",(0,r.jsxs)(e.ol,{children:["\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Time Step"}),": Balance accuracy vs. performance"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Solver Iterations"}),": More iterations = more stable but slower"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Collision Geometry"}),": Use simple shapes for collision, detailed for visuals"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Update Rate"}),": Match controller requirements"]}),"\n",(0,r.jsxs)(e.li,{children:[(0,r.jsx)(e.strong,{children:"Visual Updates"}),": Separate visual and physics update rates"]}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"parallel-processing",children:"Parallel Processing"}),"\n",(0,r.jsx)(e.p,{children:"For complex humanoid simulations, consider:"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Multi-threaded physics simulation"}),"\n",(0,r.jsx)(e.li,{children:"Distributed simulation across multiple machines"}),"\n",(0,r.jsx)(e.li,{children:"GPU acceleration for physics computation"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,r.jsx)(e.h3,{id:"instability-problems",children:"Instability Problems"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Increase solver iterations"}),"\n",(0,r.jsx)(e.li,{children:"Reduce time step size"}),"\n",(0,r.jsx)(e.li,{children:"Check mass/inertia values"}),"\n",(0,r.jsx)(e.li,{children:"Verify joint limits and dynamics"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"penetration-issues",children:"Penetration Issues"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Increase ERP (Error Reduction Parameter)"}),"\n",(0,r.jsx)(e.li,{children:"Decrease CFM (Constraint Force Mixing)"}),"\n",(0,r.jsx)(e.li,{children:"Check collision geometry overlap"}),"\n",(0,r.jsx)(e.li,{children:"Verify contact parameters"}),"\n"]}),"\n",(0,r.jsx)(e.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,r.jsxs)(e.ul,{children:["\n",(0,r.jsx)(e.li,{children:"Simplify collision geometry"}),"\n",(0,r.jsx)(e.li,{children:"Reduce update rates where possible"}),"\n",(0,r.jsx)(e.li,{children:"Use appropriate physics engine"}),"\n",(0,r.jsx)(e.li,{children:"Optimize URDF model complexity"}),"\n"]}),"\n",(0,r.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,r.jsx)(e.p,{children:"Gazebo provides a comprehensive physics simulation environment that is essential for humanoid robot development. Proper configuration of physics parameters, mass properties, and joint dynamics is crucial for realistic humanoid simulation. The integration with ROS 2 enables seamless control and monitoring of simulated humanoid robots."}),"\n",(0,r.jsx)(e.p,{children:"The key to successful humanoid simulation in Gazebo lies in understanding the balance between physical accuracy and computational performance. By carefully tuning physics parameters and using appropriate models, you can create stable and realistic humanoid simulations that bridge the gap between virtual and physical robotics."}),"\n",(0,r.jsx)(e.p,{children:"In the next chapter, we'll explore sensor simulation in Gazebo, focusing on how to accurately simulate the various sensors used in humanoid robots."})]})}function m(n={}){const{wrapper:e}={...(0,s.R)(),...n.components};return e?(0,r.jsx)(e,{...n,children:(0,r.jsx)(d,{...n})}):d(n)}},8453:(n,e,i)=>{i.d(e,{R:()=>a,x:()=>t});var r=i(6540);const s={},o=r.createContext(s);function a(n){const e=r.useContext(o);return r.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function t(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(s):n.components||s:a(n.components),r.createElement(o.Provider,{value:e},n.children)}}}]);