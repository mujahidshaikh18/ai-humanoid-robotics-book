"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[469],{5593:(n,i,r)=>{r.r(i),r.d(i,{assets:()=>l,contentTitle:()=>a,default:()=>u,frontMatter:()=>o,metadata:()=>s,toc:()=>c});var e=r(4848),t=r(8453);const o={sidebar_position:10,title:"Chapter 10: Unity for High-Fidelity Simulation"},a="Unity for High-Fidelity Simulation",s={id:"module-2/chapter-10",title:"Chapter 10: Unity for High-Fidelity Simulation",description:"Overview",source:"@site/docs/module-2/chapter-10.mdx",sourceDirName:"module-2",slug:"/module-2/chapter-10",permalink:"/ai-humanoid-robotics-book/docs/module-2/chapter-10",draft:!1,unlisted:!1,editUrl:"https://github.com/mujahidshaikh18/ai-humanoid-robotics-book/tree/main/docs/module-2/chapter-10.mdx",tags:[],version:"current",sidebarPosition:10,frontMatter:{sidebar_position:10,title:"Chapter 10: Unity for High-Fidelity Simulation"},sidebar:"tutorialSidebar",previous:{title:"Chapter 9: Environment Building",permalink:"/ai-humanoid-robotics-book/docs/module-2/chapter-9"},next:{title:"Chapter 11: Introduction to NVIDIA Isaac",permalink:"/ai-humanoid-robotics-book/docs/module-3/chapter-11"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Unity for Robotics",id:"introduction-to-unity-for-robotics",level:2},{value:"Unity Robotics Ecosystem",id:"unity-robotics-ecosystem",level:3},{value:"Setting Up Unity for Robotics",id:"setting-up-unity-for-robotics",level:2},{value:"Installing Unity",id:"installing-unity",level:3},{value:"Required Packages",id:"required-packages",level:3},{value:"Unity-Ros Integration",id:"unity-ros-integration",level:2},{value:"ROS-TCP-Connector Setup",id:"ros-tcp-connector-setup",level:3},{value:"Receiving ROS Messages in Unity",id:"receiving-ros-messages-in-unity",level:3},{value:"Humanoid Robot Model Setup",id:"humanoid-robot-model-setup",level:2},{value:"Importing Robot Models",id:"importing-robot-models",level:3},{value:"Setting Up Humanoid Rig",id:"setting-up-humanoid-rig",level:3},{value:"Physics Simulation in Unity",id:"physics-simulation-in-unity",level:2},{value:"Configuring PhysX for Humanoid Simulation",id:"configuring-physx-for-humanoid-simulation",level:3},{value:"Balance Control System",id:"balance-control-system",level:3},{value:"High-Fidelity Rendering",id:"high-fidelity-rendering",level:2},{value:"Setting Up Realistic Materials",id:"setting-up-realistic-materials",level:3},{value:"Lighting Setup for Realism",id:"lighting-setup-for-realism",level:3},{value:"Synthetic Data Generation",id:"synthetic-data-generation",level:2},{value:"Perception Package Integration",id:"perception-package-integration",level:3},{value:"ML-Agents Integration",id:"ml-agents-integration",level:2},{value:"Setting Up Reinforcement Learning Environment",id:"setting-up-reinforcement-learning-environment",level:3},{value:"Advanced Simulation Features",id:"advanced-simulation-features",level:2},{value:"Multi-Robot Simulation",id:"multi-robot-simulation",level:3},{value:"Sensor Simulation",id:"sensor-simulation",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"Level of Detail (LOD) System",id:"level-of-detail-lod-system",level:3},{value:"Occlusion Culling",id:"occlusion-culling",level:3},{value:"Integration with External Tools",id:"integration-with-external-tools",level:2},{value:"Exporting Simulation Data",id:"exporting-simulation-data",level:3},{value:"Best Practices for Unity Robotics",id:"best-practices-for-unity-robotics",level:2},{value:"1. Performance Considerations",id:"1-performance-considerations",level:3},{value:"2. Physics Optimization",id:"2-physics-optimization",level:3},{value:"3. Rendering Optimization",id:"3-rendering-optimization",level:3},{value:"4. Data Pipeline",id:"4-data-pipeline",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Physics Instability",id:"physics-instability",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"ROS Communication Problems",id:"ros-communication-problems",level:3},{value:"Summary",id:"summary",level:2}];function d(n){const i={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,e.jsxs)(e.Fragment,{children:[(0,e.jsx)(i.h1,{id:"unity-for-high-fidelity-simulation",children:"Unity for High-Fidelity Simulation"}),"\n",(0,e.jsx)(i.h2,{id:"overview",children:"Overview"}),"\n",(0,e.jsx)(i.p,{children:"Unity is a powerful game engine that has emerged as a leading platform for high-fidelity robotics simulation. With its advanced rendering capabilities, physics engine, and flexible scripting system, Unity provides an excellent environment for creating photorealistic simulations of humanoid robots. This chapter explores how to leverage Unity for robotics applications, focusing on humanoid robot simulation."}),"\n",(0,e.jsx)(i.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,e.jsx)(i.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Set up Unity for robotics simulation"}),"\n",(0,e.jsx)(i.li,{children:"Import and configure humanoid robot models"}),"\n",(0,e.jsx)(i.li,{children:"Implement physics-based simulation"}),"\n",(0,e.jsx)(i.li,{children:"Integrate Unity with ROS 2"}),"\n",(0,e.jsx)(i.li,{children:"Create photorealistic environments"}),"\n",(0,e.jsx)(i.li,{children:"Generate synthetic training data"}),"\n"]}),"\n",(0,e.jsx)(i.h2,{id:"introduction-to-unity-for-robotics",children:"Introduction to Unity for Robotics"}),"\n",(0,e.jsx)(i.p,{children:"Unity has become increasingly popular in robotics research and development due to its:"}),"\n",(0,e.jsxs)(i.ol,{children:["\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"High-Fidelity Rendering"}),": Photorealistic graphics capabilities"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Physics Engine"}),": Realistic physics simulation with PhysX"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Asset Store"}),": Extensive library of models and environments"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Scripting"}),": Flexible C# scripting for custom behaviors"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"XR Support"}),": Virtual and augmented reality capabilities"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Performance"}),": Optimized for real-time simulation"]}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"unity-robotics-ecosystem",children:"Unity Robotics Ecosystem"}),"\n",(0,e.jsx)(i.p,{children:"The Unity robotics ecosystem includes several key components:"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Unity Robotics Hub"}),": Centralized access to robotics tools"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Unity Robotics Package"}),": ROS/ROS2 integration"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Unity ML-Agents"}),": Machine learning for robotics"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Unity Perception"}),": Synthetic data generation"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Unity Simulation"}),": Large-scale simulation capabilities"]}),"\n"]}),"\n",(0,e.jsx)(i.h2,{id:"setting-up-unity-for-robotics",children:"Setting Up Unity for Robotics"}),"\n",(0,e.jsx)(i.h3,{id:"installing-unity",children:"Installing Unity"}),"\n",(0,e.jsx)(i.p,{children:"For robotics applications, it's recommended to use Unity 2021.3 LTS (Long Term Support) or later:"}),"\n",(0,e.jsxs)(i.ol,{children:["\n",(0,e.jsx)(i.li,{children:"Download Unity Hub from the Unity website"}),"\n",(0,e.jsx)(i.li,{children:"Install Unity Editor with the Universal Render Pipeline (URP) or High Definition Render Pipeline (HDRP)"}),"\n",(0,e.jsx)(i.li,{children:"Install the Robotics packages through Unity Package Manager"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"required-packages",children:"Required Packages"}),"\n",(0,e.jsx)(i.p,{children:"Install these essential packages for robotics simulation:"}),"\n",(0,e.jsxs)(i.ol,{children:["\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"ROS-TCP-Connector"}),": For ROS communication"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"ML-Agents"}),": For reinforcement learning"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Perception"}),": For synthetic data generation"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"XR packages"}),": For extended reality applications"]}),"\n"]}),"\n",(0,e.jsx)(i.h2,{id:"unity-ros-integration",children:"Unity-Ros Integration"}),"\n",(0,e.jsx)(i.h3,{id:"ros-tcp-connector-setup",children:"ROS-TCP-Connector Setup"}),"\n",(0,e.jsx)(i.p,{children:"The ROS-TCP-Connector enables communication between Unity and ROS 2:"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Sensor;\r\nusing RosMessageTypes.Geometry;\r\n\r\npublic class UnityRobotController : MonoBehaviour\r\n{\r\n    ROSConnection ros;\r\n    string rosTopic = "unity_robot_command";\r\n\r\n    // Robot joint transforms\r\n    public Transform leftHip;\r\n    public Transform rightHip;\r\n    public Transform leftKnee;\r\n    public Transform rightKnee;\r\n\r\n    // Start is called before the first frame update\r\n    void Start()\r\n    {\r\n        // Get the ROS connection static instance\r\n        ros = ROSConnection.GetOrCreateInstance();\r\n        ros.RegisterPublisher<JointStateMsg>(rosTopic);\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // Send joint states to ROS\r\n        SendJointStates();\r\n    }\r\n\r\n    void SendJointStates()\r\n    {\r\n        // Create and populate joint state message\r\n        var jointState = new JointStateMsg();\r\n        jointState.name = new string[] {\r\n            "left_hip", "right_hip", "left_knee", "right_knee"\r\n        };\r\n        jointState.position = new double[] {\r\n            leftHip.localEulerAngles.y,\r\n            rightHip.localEulerAngles.y,\r\n            leftKnee.localEulerAngles.x,\r\n            rightKnee.localEulerAngles.x\r\n        };\r\n        jointState.header.stamp = new TimeStamp(0, 0);\r\n        jointState.header.frame_id = "base_link";\r\n\r\n        // Publish the message\r\n        ros.Publish(rosTopic, jointState);\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h3,{id:"receiving-ros-messages-in-unity",children:"Receiving ROS Messages in Unity"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using System.Collections;\r\nusing System.Collections.Generic;\r\nusing UnityEngine;\r\nusing Unity.Robotics.ROSTCPConnector;\r\nusing RosMessageTypes.Geometry;\r\n\r\npublic class UnityROSReceiver : MonoBehaviour\r\n{\r\n    ROSConnection ros;\r\n    string rosTopic = "cmd_vel";\r\n\r\n    // Robot parts to control\r\n    public Transform robotBody;\r\n    public float moveSpeed = 1.0f;\r\n\r\n    void Start()\r\n    {\r\n        ros = ROSConnection.GetOrCreateInstance();\r\n        ros.Subscribe<TwistMsg>(rosTopic, CmdVelCallback);\r\n    }\r\n\r\n    void CmdVelCallback(TwistMsg cmd)\r\n    {\r\n        // Apply movement to robot\r\n        Vector3 movement = new Vector3((float)cmd.linear.x, 0, (float)cmd.angular.z);\r\n        robotBody.Translate(movement * moveSpeed * Time.deltaTime);\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h2,{id:"humanoid-robot-model-setup",children:"Humanoid Robot Model Setup"}),"\n",(0,e.jsx)(i.h3,{id:"importing-robot-models",children:"Importing Robot Models"}),"\n",(0,e.jsx)(i.p,{children:"When importing humanoid robot models into Unity:"}),"\n",(0,e.jsxs)(i.ol,{children:["\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Model Format"}),": Use FBX format for best compatibility"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Scale"}),": Ensure models are correctly scaled (1 unit = 1 meter)"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Origin"}),": Center the model at the origin for easier manipulation"]}),"\n",(0,e.jsxs)(i.li,{children:[(0,e.jsx)(i.strong,{children:"Hierarchy"}),": Maintain proper joint hierarchy for animation"]}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"setting-up-humanoid-rig",children:"Setting Up Humanoid Rig"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\r\n\r\npublic class HumanoidRigSetup : MonoBehaviour\r\n{\r\n    // Humanoid joint references\r\n    public Transform pelvis;\r\n    public Transform spine;\r\n    public Transform chest;\r\n    public Transform neck;\r\n    public Transform head;\r\n\r\n    public Transform leftHip;\r\n    public Transform leftKnee;\r\n    public Transform leftAnkle;\r\n    public Transform leftFoot;\r\n\r\n    public Transform rightHip;\r\n    public Transform rightKnee;\r\n    public Transform rightAnkle;\r\n    public Transform rightFoot;\r\n\r\n    public Transform leftShoulder;\r\n    public Transform leftElbow;\r\n    public Transform leftWrist;\r\n    public Transform leftHand;\r\n\r\n    public Transform rightShoulder;\r\n    public Transform rightElbow;\r\n    public Transform rightWrist;\r\n    public Transform rightHand;\r\n\r\n    void Start()\r\n    {\r\n        SetupRigConstraints();\r\n    }\r\n\r\n    void SetupRigConstraints()\r\n    {\r\n        // Configure joint limits and constraints\r\n        ConfigureJointLimits(leftHip, -45f, 45f, -10f, 10f, -10f, 10f);\r\n        ConfigureJointLimits(rightHip, -45f, 45f, -10f, 10f, -10f, 10f);\r\n        ConfigureJointLimits(leftKnee, 0f, 130f, 0f, 0f, 0f, 0f);\r\n        ConfigureJointLimits(rightKnee, 0f, 130f, 0f, 0f, 0f, 0f);\r\n    }\r\n\r\n    void ConfigureJointLimits(Transform joint, float xMin, float xMax,\r\n                             float yMin, float yMax, float zMin, float zMax)\r\n    {\r\n        ConfigurableJoint configJoint = joint.GetComponent<ConfigurableJoint>();\r\n        if (configJoint == null)\r\n        {\r\n            configJoint = joint.gameObject.AddComponent<ConfigurableJoint>();\r\n        }\r\n\r\n        // Set angular limits\r\n        SoftJointLimit limit = new SoftJointLimit();\r\n        limit.limit = 45f; // Default limit\r\n        configJoint.angularXLimit = limit;\r\n        configJoint.angularYLimit = limit;\r\n        configJoint.angularZLimit = limit;\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(i.h2,{id:"physics-simulation-in-unity",children:"Physics Simulation in Unity"}),"\n",(0,e.jsx)(i.h3,{id:"configuring-physx-for-humanoid-simulation",children:"Configuring PhysX for Humanoid Simulation"}),"\n",(0,e.jsx)(i.p,{children:"Unity's PhysX engine provides realistic physics simulation:"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class HumanoidPhysicsSetup : MonoBehaviour\r\n{\r\n    public float gravityScale = 1.0f;\r\n    public float massScale = 1.0f;\r\n\r\n    void Start()\r\n    {\r\n        SetupPhysicsProperties();\r\n    }\r\n\r\n    void SetupPhysicsProperties()\r\n    {\r\n        // Configure gravity\r\n        Physics.gravity = new Vector3(0, -9.81f * gravityScale, 0);\r\n\r\n        // Configure each body part with appropriate mass\r\n        ConfigureBodyPartMass("pelvis", 10.0f * massScale);\r\n        ConfigureBodyPartMass("torso", 20.0f * massScale);\r\n        ConfigureBodyPartMass("head", 3.0f * massScale);\r\n        ConfigureBodyPartMass("upper_arm", 2.0f * massScale);\r\n        ConfigureBodyPartMass("lower_arm", 1.5f * massScale);\r\n        ConfigureBodyPartMass("thigh", 5.0f * massScale);\r\n        ConfigureBodyPartMass("shin", 3.0f * massScale);\r\n        ConfigureBodyPartMass("foot", 1.0f * massScale);\r\n    }\r\n\r\n    void ConfigureBodyPartMass(string partName, float mass)\r\n    {\r\n        Transform part = transform.Find(partName);\r\n        if (part != null)\r\n        {\r\n            Rigidbody rb = part.GetComponent<Rigidbody>();\r\n            if (rb == null)\r\n            {\r\n                rb = part.gameObject.AddComponent<Rigidbody>();\r\n            }\r\n            rb.mass = mass;\r\n            rb.interpolation = RigidbodyInterpolation.Interpolate;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h3,{id:"balance-control-system",children:"Balance Control System"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\r\n\r\npublic class HumanoidBalanceController : MonoBehaviour\r\n{\r\n    public Transform centerOfMass;\r\n    public Transform leftFoot;\r\n    public Transform rightFoot;\r\n    public float balanceThreshold = 0.1f;\r\n    public float recoverySpeed = 5.0f;\r\n\r\n    private Rigidbody rb;\r\n\r\n    void Start()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n        if (rb != null)\r\n        {\r\n            rb.centerOfMass = centerOfMass.localPosition;\r\n        }\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        MaintainBalance();\r\n    }\r\n\r\n    void MaintainBalance()\r\n    {\r\n        if (rb == null) return;\r\n\r\n        // Calculate center of mass position relative to feet\r\n        Vector3 comPosition = transform.TransformPoint(centerOfMass.localPosition);\r\n        Vector3 leftFootPos = new Vector3(leftFoot.position.x, comPosition.y, leftFoot.position.z);\r\n        Vector3 rightFootPos = new Vector3(rightFoot.position.x, comPosition.y, rightFoot.position.z);\r\n\r\n        // Calculate support polygon (simplified as line between feet)\r\n        float supportCenterX = (leftFootPos.x + rightFootPos.x) / 2f;\r\n        float supportWidth = Mathf.Abs(leftFootPos.x - rightFootPos.x);\r\n\r\n        // Check if COM is within support polygon\r\n        float comOffset = Mathf.Abs(comPosition.x - supportCenterX);\r\n\r\n        if (comOffset > supportWidth / 2f + balanceThreshold)\r\n        {\r\n            // Apply corrective torque to maintain balance\r\n            Vector3 correctiveTorque = Vector3.zero;\r\n            correctiveTorque.z = (supportCenterX - comPosition.x) * recoverySpeed;\r\n            rb.AddTorque(correctiveTorque, ForceMode.Acceleration);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(i.h2,{id:"high-fidelity-rendering",children:"High-Fidelity Rendering"}),"\n",(0,e.jsx)(i.h3,{id:"setting-up-realistic-materials",children:"Setting Up Realistic Materials"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class MaterialSetup : MonoBehaviour\r\n{\r\n    public Material metalMaterial;\r\n    public Material rubberMaterial;\r\n    public Material plasticMaterial;\r\n\r\n    void Start()\r\n    {\r\n        SetupRobotMaterials();\r\n    }\r\n\r\n    void SetupRobotMaterials()\r\n    {\r\n        // Apply materials to different robot parts\r\n        ApplyMaterial("head", metalMaterial);\r\n        ApplyMaterial("torso", metalMaterial);\r\n        ApplyMaterial("upper_arm", metalMaterial);\r\n        ApplyMaterial("lower_arm", metalMaterial);\r\n        ApplyMaterial("hand", rubberMaterial);\r\n        ApplyMaterial("foot", rubberMaterial);\r\n    }\r\n\r\n    void ApplyMaterial(string partName, Material material)\r\n    {\r\n        Transform part = transform.Find(partName);\r\n        if (part != null)\r\n        {\r\n            Renderer renderer = part.GetComponent<Renderer>();\r\n            if (renderer != null)\r\n            {\r\n                renderer.material = material;\r\n            }\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h3,{id:"lighting-setup-for-realism",children:"Lighting Setup for Realism"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\r\n\r\npublic class RealisticLightingSetup : MonoBehaviour\r\n{\r\n    public Light mainLight;\r\n    public Light fillLight;\r\n    public Light rimLight;\r\n\r\n    void Start()\r\n    {\r\n        SetupLighting();\r\n    }\r\n\r\n    void SetupLighting()\r\n    {\r\n        // Main directional light (sun/simulation light)\r\n        if (mainLight != null)\r\n        {\r\n            mainLight.type = LightType.Directional;\r\n            mainLight.intensity = 1.0f;\r\n            mainLight.color = Color.white;\r\n            mainLight.transform.rotation = Quaternion.Euler(50f, -30f, 0f);\r\n        }\r\n\r\n        // Fill light to reduce harsh shadows\r\n        if (fillLight != null)\r\n        {\r\n            fillLight.type = LightType.Directional;\r\n            fillLight.intensity = 0.3f;\r\n            fillLight.color = Color.gray;\r\n            fillLight.transform.rotation = Quaternion.Euler(-50f, 150f, 0f);\r\n        }\r\n\r\n        // Rim light for edge definition\r\n        if (rimLight != null)\r\n        {\r\n            rimLight.type = LightType.Directional;\r\n            rimLight.intensity = 0.2f;\r\n            rimLight.color = Color.blue;\r\n            rimLight.transform.rotation = Quaternion.Euler(10f, 210f, 0f);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(i.h2,{id:"synthetic-data-generation",children:"Synthetic Data Generation"}),"\n",(0,e.jsx)(i.h3,{id:"perception-package-integration",children:"Perception Package Integration"}),"\n",(0,e.jsx)(i.p,{children:"Unity's Perception package enables synthetic data generation:"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing Unity.Perception.GroundTruth;\r\nusing Unity.Perception.Randomization.Samplers;\r\n\r\npublic class SyntheticDataGenerator : MonoBehaviour\r\n{\r\n    public GameObject robot;\r\n    public GameObject[] environmentObjects;\r\n    public int datasetSize = 1000;\r\n\r\n    void Start()\r\n    {\r\n        GenerateSyntheticDataset();\r\n    }\r\n\r\n    void GenerateSyntheticDataset()\r\n    {\r\n        for (int i = 0; i < datasetSize; i++)\r\n        {\r\n            // Randomize environment\r\n            RandomizeEnvironment();\r\n\r\n            // Randomize robot pose\r\n            RandomizeRobotPose();\r\n\r\n            // Capture synthetic data\r\n            CaptureSyntheticImage(i);\r\n        }\r\n    }\r\n\r\n    void RandomizeEnvironment()\r\n    {\r\n        foreach (GameObject obj in environmentObjects)\r\n        {\r\n            // Randomize position\r\n            obj.transform.position = new Vector3(\r\n                Random.Range(-5f, 5f),\r\n                0f,\r\n                Random.Range(-5f, 5f)\r\n            );\r\n\r\n            // Randomize rotation\r\n            obj.transform.rotation = Quaternion.Euler(\r\n                0f,\r\n                Random.Range(0f, 360f),\r\n                0f\r\n            );\r\n        }\r\n    }\r\n\r\n    void RandomizeRobotPose()\r\n    {\r\n        // Randomize robot position\r\n        robot.transform.position = new Vector3(\r\n            Random.Range(-2f, 2f),\r\n            0f,\r\n            Random.Range(-2f, 2f)\r\n        );\r\n\r\n        // Randomize robot orientation\r\n        robot.transform.rotation = Quaternion.Euler(\r\n            0f,\r\n            Random.Range(0f, 360f),\r\n            0f\r\n        );\r\n    }\r\n\r\n    void CaptureSyntheticImage(int index)\r\n    {\r\n        // In a real implementation, you would use Perception package\r\n        // to capture images with semantic segmentation, depth, etc.\r\n        Debug.Log($"Captured synthetic image {index + 1}/{datasetSize}");\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h2,{id:"ml-agents-integration",children:"ML-Agents Integration"}),"\n",(0,e.jsx)(i.h3,{id:"setting-up-reinforcement-learning-environment",children:"Setting Up Reinforcement Learning Environment"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using Unity.MLAgents;\r\nusing Unity.MLAgents.Sensors;\r\nusing Unity.MLAgents.Actuators;\r\nusing UnityEngine;\r\n\r\npublic class HumanoidLearningAgent : Agent\r\n{\r\n    public Transform target;\r\n    public float moveSpeed = 5.0f;\r\n    public float rotationSpeed = 100.0f;\r\n\r\n    private Rigidbody rb;\r\n    private float distanceToTarget;\r\n\r\n    public override void Initialize()\r\n    {\r\n        rb = GetComponent<Rigidbody>();\r\n        distanceToTarget = Vector3.Distance(transform.position, target.position);\r\n    }\r\n\r\n    public override void OnEpisodeBegin()\r\n    {\r\n        // Reset agent position\r\n        transform.position = new Vector3(\r\n            Random.Range(-3f, 3f),\r\n            1f,\r\n            Random.Range(-3f, 3f)\r\n        );\r\n\r\n        // Reset target position\r\n        target.position = new Vector3(\r\n            Random.Range(-4f, 4f),\r\n            0.5f,\r\n            Random.Range(-4f, 4f)\r\n        );\r\n\r\n        distanceToTarget = Vector3.Distance(transform.position, target.position);\r\n    }\r\n\r\n    public override void CollectObservations(VectorSensor sensor)\r\n    {\r\n        // Agent position and rotation\r\n        sensor.AddObservation(transform.position);\r\n        sensor.AddObservation(transform.rotation.eulerAngles);\r\n\r\n        // Target position relative to agent\r\n        sensor.AddObservation(target.position - transform.position);\r\n\r\n        // Velocity\r\n        sensor.AddObservation(rb.velocity);\r\n\r\n        // Distance to target\r\n        sensor.AddObservation(distanceToTarget);\r\n    }\r\n\r\n    public override void OnActionReceived(ActionBuffers actions)\r\n    {\r\n        // Actions: [0] forward/back, [1] left/right, [2] rotate\r\n        float forward = actions.ContinuousActions[0];\r\n        float strafe = actions.ContinuousActions[1];\r\n        float rotate = actions.ContinuousActions[2];\r\n\r\n        // Move the agent\r\n        Vector3 movement = new Vector3(strafe, 0, forward) * moveSpeed * Time.deltaTime;\r\n        transform.Translate(movement);\r\n\r\n        // Rotate the agent\r\n        transform.Rotate(0, rotate * rotationSpeed * Time.deltaTime, 0);\r\n\r\n        // Calculate new distance to target\r\n        float newDistance = Vector3.Distance(transform.position, target.position);\r\n\r\n        // Reward based on distance to target\r\n        float reward = (distanceToTarget - newDistance) * 10f;\r\n        SetReward(reward);\r\n\r\n        distanceToTarget = newDistance;\r\n\r\n        // Check if reached target\r\n        if (newDistance < 1.0f)\r\n        {\r\n            SetReward(10.0f);\r\n            EndEpisode();\r\n        }\r\n\r\n        // Check if agent fell\r\n        if (transform.position.y < -1.0f)\r\n        {\r\n            SetReward(-10.0f);\r\n            EndEpisode();\r\n        }\r\n    }\r\n\r\n    public override void Heuristic(in ActionBuffers actionsOut)\r\n    {\r\n        // Manual control for testing\r\n        var continuousActionsOut = actionsOut.ContinuousActions;\r\n        continuousActionsOut[0] = Input.GetAxis("Vertical"); // Forward/back\r\n        continuousActionsOut[1] = Input.GetAxis("Horizontal"); // Left/right\r\n        continuousActionsOut[2] = Input.GetKey(KeyCode.Q) ? -1f :\r\n                     Input.GetKey(KeyCode.E) ? 1f : 0f; // Rotate\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h2,{id:"advanced-simulation-features",children:"Advanced Simulation Features"}),"\n",(0,e.jsx)(i.h3,{id:"multi-robot-simulation",children:"Multi-Robot Simulation"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using System.Collections.Generic;\r\nusing UnityEngine;\r\n\r\npublic class MultiRobotSimulation : MonoBehaviour\r\n{\r\n    public GameObject robotPrefab;\r\n    public int robotCount = 5;\r\n    public float spawnRadius = 10f;\r\n\r\n    private List<GameObject> robots = new List<GameObject>();\r\n\r\n    void Start()\r\n    {\r\n        SpawnRobots();\r\n    }\r\n\r\n    void SpawnRobots()\r\n    {\r\n        for (int i = 0; i < robotCount; i++)\r\n        {\r\n            // Calculate spawn position in a circle\r\n            float angle = (2 * Mathf.PI * i) / robotCount;\r\n            Vector3 spawnPosition = new Vector3(\r\n                Mathf.Cos(angle) * spawnRadius,\r\n                1f,\r\n                Mathf.Sin(angle) * spawnRadius\r\n            );\r\n\r\n            // Instantiate robot\r\n            GameObject robot = Instantiate(robotPrefab, spawnPosition, Quaternion.identity);\r\n            robots.Add(robot);\r\n\r\n            // Assign unique ID\r\n            robot.name = $"Robot_{i:D2}";\r\n        }\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        // Coordinate robot behaviors\r\n        CoordinateRobots();\r\n    }\r\n\r\n    void CoordinateRobots()\r\n    {\r\n        // Example: Simple formation control\r\n        for (int i = 0; i < robots.Count; i++)\r\n        {\r\n            GameObject robot = robots[i];\r\n            float angle = (2 * Mathf.PI * i) / robotCount;\r\n            Vector3 targetPosition = new Vector3(\r\n                Mathf.Cos(angle) * 5f,\r\n                1f,\r\n                Mathf.Sin(angle) * 5f\r\n            );\r\n\r\n            // Move robot toward formation position\r\n            Vector3 direction = (targetPosition - robot.transform.position).normalized;\r\n            robot.transform.position += direction * 0.01f;\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h3,{id:"sensor-simulation",children:"Sensor Simulation"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\r\nusing System.Collections.Generic;\r\n\r\npublic class UnitySensorSimulation : MonoBehaviour\r\n{\r\n    public float sensorRange = 10f;\r\n    public int sensorResolution = 360;\r\n    public LayerMask detectionMask;\r\n\r\n    private float[] sensorReadings;\r\n\r\n    void Start()\r\n    {\r\n        sensorReadings = new float[sensorResolution];\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        SimulateLidarScan();\r\n    }\r\n\r\n    void SimulateLidarScan()\r\n    {\r\n        for (int i = 0; i < sensorResolution; i++)\r\n        {\r\n            float angle = (2 * Mathf.PI * i) / sensorResolution;\r\n            Vector3 direction = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\r\n\r\n            RaycastHit hit;\r\n            if (Physics.Raycast(transform.position, direction, out hit, sensorRange, detectionMask))\r\n            {\r\n                sensorReadings[i] = hit.distance;\r\n            }\r\n            else\r\n            {\r\n                sensorReadings[i] = sensorRange; // No obstacle detected\r\n            }\r\n        }\r\n\r\n        // In a real implementation, you would publish this data to ROS\r\n        PublishSensorData();\r\n    }\r\n\r\n    void PublishSensorData()\r\n    {\r\n        // Convert to ROS LaserScan message and publish\r\n        // This would use the ROS-TCP-Connector\r\n    }\r\n\r\n    // Visualization for debugging\r\n    void OnDrawGizmosSelected()\r\n    {\r\n        if (sensorReadings == null) return;\r\n\r\n        for (int i = 0; i < sensorResolution; i++)\r\n        {\r\n            float angle = (2 * Mathf.PI * i) / sensorResolution;\r\n            Vector3 direction = new Vector3(Mathf.Cos(angle), 0, Mathf.Sin(angle));\r\n            float distance = sensorReadings[i];\r\n\r\n            Gizmos.color = distance < sensorRange ? Color.red : Color.green;\r\n            Gizmos.DrawRay(transform.position, direction * distance);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(i.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,e.jsx)(i.h3,{id:"level-of-detail-lod-system",children:"Level of Detail (LOD) System"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:"using UnityEngine;\r\n\r\npublic class RobotLODSystem : MonoBehaviour\r\n{\r\n    public Transform[] lodLevels;\r\n    public float[] lodDistances;\r\n    public Camera mainCamera;\r\n\r\n    void Start()\r\n    {\r\n        if (mainCamera == null)\r\n        {\r\n            mainCamera = Camera.main;\r\n        }\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        UpdateLOD();\r\n    }\r\n\r\n    void UpdateLOD()\r\n    {\r\n        if (mainCamera == null) return;\r\n\r\n        float distance = Vector3.Distance(transform.position, mainCamera.transform.position);\r\n\r\n        for (int i = 0; i < lodLevels.Length; i++)\r\n        {\r\n            if (distance <= lodDistances[i])\r\n            {\r\n                ActivateLOD(i);\r\n                break;\r\n            }\r\n        }\r\n    }\r\n\r\n    void ActivateLOD(int level)\r\n    {\r\n        for (int i = 0; i < lodLevels.Length; i++)\r\n        {\r\n            lodLevels[i].gameObject.SetActive(i == level);\r\n        }\r\n    }\r\n}\n"})}),"\n",(0,e.jsx)(i.h3,{id:"occlusion-culling",children:"Occlusion Culling"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\n\r\npublic class OcclusionCullingSetup : MonoBehaviour\r\n{\r\n    public bool useOcclusionCulling = true;\r\n\r\n    void Start()\r\n    {\r\n        SetupOcclusionCulling();\r\n    }\r\n\r\n    void SetupOcclusionCulling()\r\n    {\r\n        if (useOcclusionCulling)\r\n        {\r\n            // In the Unity editor, you would bake occlusion data\r\n            // This is typically done through the Lighting window\r\n            Debug.Log("Occlusion culling should be baked in the editor");\r\n        }\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h2,{id:"integration-with-external-tools",children:"Integration with External Tools"}),"\n",(0,e.jsx)(i.h3,{id:"exporting-simulation-data",children:"Exporting Simulation Data"}),"\n",(0,e.jsx)(i.pre,{children:(0,e.jsx)(i.code,{className:"language-csharp",children:'using UnityEngine;\r\nusing System.IO;\r\nusing System.Collections.Generic;\r\n\r\npublic class SimulationDataExporter : MonoBehaviour\r\n{\r\n    public string exportPath = "simulation_data";\r\n    public int frameRate = 30;\r\n\r\n    private List<SimulationFrame> simulationData = new List<SimulationFrame>();\r\n    private float lastExportTime;\r\n\r\n    void Start()\r\n    {\r\n        lastExportTime = Time.time;\r\n        Directory.CreateDirectory(exportPath);\r\n    }\r\n\r\n    void Update()\r\n    {\r\n        if (Time.time - lastExportTime >= 1f / frameRate)\r\n        {\r\n            CaptureFrame();\r\n            lastExportTime = Time.time;\r\n        }\r\n    }\r\n\r\n    void CaptureFrame()\r\n    {\r\n        SimulationFrame frame = new SimulationFrame\r\n        {\r\n            timestamp = Time.time,\r\n            robotPositions = new List<Vector3>(),\r\n            robotRotations = new List<Quaternion>()\r\n        };\r\n\r\n        // Capture all robot positions and rotations\r\n        // This would be expanded based on your robot setup\r\n        frame.robotPositions.Add(transform.position);\r\n        frame.robotRotations.Add(transform.rotation);\r\n\r\n        simulationData.Add(frame);\r\n\r\n        // Export to file periodically\r\n        if (simulationData.Count % 100 == 0)\r\n        {\r\n            ExportData();\r\n        }\r\n    }\r\n\r\n    void ExportData()\r\n    {\r\n        string fileName = Path.Combine(exportPath, $"simulation_data_{simulationData.Count}.json");\r\n        string jsonData = JsonUtility.ToJson(new SimulationDataContainer { frames = simulationData.ToArray() }, true);\r\n        File.WriteAllText(fileName, jsonData);\r\n\r\n        Debug.Log($"Exported {simulationData.Count} frames to {fileName}");\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class SimulationFrame\r\n    {\r\n        public float timestamp;\r\n        public List<Vector3> robotPositions;\r\n        public List<Quaternion> robotRotations;\r\n    }\r\n\r\n    [System.Serializable]\r\n    public class SimulationDataContainer\r\n    {\r\n        public SimulationFrame[] frames;\r\n    }\r\n}\n'})}),"\n",(0,e.jsx)(i.h2,{id:"best-practices-for-unity-robotics",children:"Best Practices for Unity Robotics"}),"\n",(0,e.jsx)(i.h3,{id:"1-performance-considerations",children:"1. Performance Considerations"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Use object pooling for frequently instantiated objects"}),"\n",(0,e.jsx)(i.li,{children:"Optimize mesh complexity for physics calculations"}),"\n",(0,e.jsx)(i.li,{children:"Implement Level of Detail (LOD) systems"}),"\n",(0,e.jsx)(i.li,{children:"Use occlusion culling for large environments"}),"\n",(0,e.jsx)(i.li,{children:"Profile regularly to identify bottlenecks"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"2-physics-optimization",children:"2. Physics Optimization"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Use appropriate collision shapes"}),"\n",(0,e.jsx)(i.li,{children:"Adjust physics update rates for stability"}),"\n",(0,e.jsx)(i.li,{children:"Configure joint limits and constraints properly"}),"\n",(0,e.jsx)(i.li,{children:"Use fixed time steps for consistent physics"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"3-rendering-optimization",children:"3. Rendering Optimization"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Use efficient lighting techniques"}),"\n",(0,e.jsx)(i.li,{children:"Implement texture atlasing"}),"\n",(0,e.jsx)(i.li,{children:"Use shader optimization"}),"\n",(0,e.jsx)(i.li,{children:"Consider using URP for performance vs. HDRP for quality"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"4-data-pipeline",children:"4. Data Pipeline"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Implement proper logging and debugging"}),"\n",(0,e.jsx)(i.li,{children:"Create automated testing pipelines"}),"\n",(0,e.jsx)(i.li,{children:"Validate simulation-to-reality transfer"}),"\n",(0,e.jsx)(i.li,{children:"Document simulation parameters thoroughly"}),"\n"]}),"\n",(0,e.jsx)(i.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,e.jsx)(i.h3,{id:"physics-instability",children:"Physics Instability"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Check mass ratios between connected bodies"}),"\n",(0,e.jsx)(i.li,{children:"Ensure proper joint configurations"}),"\n",(0,e.jsx)(i.li,{children:"Adjust solver iteration counts"}),"\n",(0,e.jsx)(i.li,{children:"Verify center of mass positioning"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Reduce polygon count where possible"}),"\n",(0,e.jsx)(i.li,{children:"Use fewer real-time lights"}),"\n",(0,e.jsx)(i.li,{children:"Optimize material complexity"}),"\n",(0,e.jsx)(i.li,{children:"Consider using simpler physics approximations"}),"\n"]}),"\n",(0,e.jsx)(i.h3,{id:"ros-communication-problems",children:"ROS Communication Problems"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"Verify TCP connection settings"}),"\n",(0,e.jsx)(i.li,{children:"Check message serialization"}),"\n",(0,e.jsx)(i.li,{children:"Validate topic names and types"}),"\n",(0,e.jsx)(i.li,{children:"Monitor network bandwidth usage"}),"\n"]}),"\n",(0,e.jsx)(i.h2,{id:"summary",children:"Summary"}),"\n",(0,e.jsx)(i.p,{children:"Unity provides a powerful platform for high-fidelity humanoid robot simulation, offering photorealistic rendering, advanced physics simulation, and flexible scripting capabilities. The integration with ROS through the ROS-TCP-Connector enables seamless communication between Unity and the ROS ecosystem."}),"\n",(0,e.jsx)(i.p,{children:"Key advantages of Unity for humanoid simulation include:"}),"\n",(0,e.jsxs)(i.ul,{children:["\n",(0,e.jsx)(i.li,{children:"High-quality visual rendering for realistic perception simulation"}),"\n",(0,e.jsx)(i.li,{children:"Advanced physics engine for accurate dynamics"}),"\n",(0,e.jsx)(i.li,{children:"Flexible scripting system for custom behaviors"}),"\n",(0,e.jsx)(i.li,{children:"Extensive asset library and tooling"}),"\n",(0,e.jsx)(i.li,{children:"Machine learning integration through ML-Agents"}),"\n"]}),"\n",(0,e.jsx)(i.p,{children:"The combination of Unity's capabilities with ROS's robotics infrastructure creates a powerful simulation environment that bridges the gap between virtual and real-world robotics development. This high-fidelity simulation capability is essential for developing and testing humanoid robots before deployment on physical hardware."}),"\n",(0,e.jsx)(i.p,{children:"In the next module, we'll explore NVIDIA Isaac for advanced AI robotics applications, building on the simulation foundations established in this module."})]})}function u(n={}){const{wrapper:i}={...(0,t.R)(),...n.components};return i?(0,e.jsx)(i,{...n,children:(0,e.jsx)(d,{...n})}):d(n)}},8453:(n,i,r)=>{r.d(i,{R:()=>a,x:()=>s});var e=r(6540);const t={},o=e.createContext(t);function a(n){const i=e.useContext(o);return e.useMemo(function(){return"function"==typeof n?n(i):{...i,...n}},[i,n])}function s(n){let i;return i=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:a(n.components),e.createElement(o.Provider,{value:i},n.children)}}}]);