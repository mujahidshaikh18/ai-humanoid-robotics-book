"use strict";(globalThis.webpackChunkphysical_ai_humanoid_robotics_book=globalThis.webpackChunkphysical_ai_humanoid_robotics_book||[]).push([[123],{5150:(n,e,r)=>{r.r(e),r.d(e,{assets:()=>l,contentTitle:()=>o,default:()=>_,frontMatter:()=>i,metadata:()=>s,toc:()=>c});var a=r(4848),t=r(8453);const i={sidebar_position:14,title:"Chapter 14: Path Planning with Nav2"},o="Path Planning with Nav2",s={id:"module-3/chapter-14",title:"Chapter 14: Path Planning with Nav2",description:"Overview",source:"@site/docs/module-3/chapter-14.mdx",sourceDirName:"module-3",slug:"/module-3/chapter-14",permalink:"/ai-humanoid-robotics-book/docs/module-3/chapter-14",draft:!1,unlisted:!1,editUrl:"https://github.com/mujahidshaikh18/ai-humanoid-robotics-book/tree/main/docs/module-3/chapter-14.mdx",tags:[],version:"current",sidebarPosition:14,frontMatter:{sidebar_position:14,title:"Chapter 14: Path Planning with Nav2"},sidebar:"tutorialSidebar",previous:{title:"Chapter 13: Isaac ROS: Hardware-Accelerated Robotics",permalink:"/ai-humanoid-robotics-book/docs/module-3/chapter-13"},next:{title:"Chapter 15: Reinforcement Learning & Sim-to-Real",permalink:"/ai-humanoid-robotics-book/docs/module-3/chapter-15"}},l={},c=[{value:"Overview",id:"overview",level:2},{value:"Learning Objectives",id:"learning-objectives",level:2},{value:"Introduction to Nav2",id:"introduction-to-nav2",level:2},{value:"Nav2 Architecture",id:"nav2-architecture",level:3},{value:"Key Components of Nav2",id:"key-components-of-nav2",level:3},{value:"Nav2 Configuration for Humanoid Robots",id:"nav2-configuration-for-humanoid-robots",level:2},{value:"Basic Nav2 Setup",id:"basic-nav2-setup",level:3},{value:"Isaac Integration with Nav2",id:"isaac-integration-with-nav2",level:2},{value:"GPU-Accelerated Path Planning",id:"gpu-accelerated-path-planning",level:3},{value:"Humanoid-Specific Navigation Considerations",id:"humanoid-specific-navigation-considerations",level:2},{value:"Bipedal Locomotion Integration",id:"bipedal-locomotion-integration",level:3},{value:"Advanced Path Planning Algorithms",id:"advanced-path-planning-algorithms",level:2},{value:"GPU-Accelerated Dijkstra&#39;s Algorithm",id:"gpu-accelerated-dijkstras-algorithm",level:3},{value:"Behavior Trees for Navigation",id:"behavior-trees-for-navigation",level:2},{value:"Nav2 Behavior Tree Integration",id:"nav2-behavior-tree-integration",level:3},{value:"Performance Optimization",id:"performance-optimization",level:2},{value:"GPU Resource Management",id:"gpu-resource-management",level:3},{value:"Best Practices for Nav2 with Isaac",id:"best-practices-for-nav2-with-isaac",level:2},{value:"1. Configuration Optimization",id:"1-configuration-optimization",level:3},{value:"2. Performance Considerations",id:"2-performance-considerations",level:3},{value:"3. Safety and Reliability",id:"3-safety-and-reliability",level:3},{value:"4. Testing and Validation",id:"4-testing-and-validation",level:3},{value:"Troubleshooting Common Issues",id:"troubleshooting-common-issues",level:2},{value:"Path Planning Problems",id:"path-planning-problems",level:3},{value:"Performance Issues",id:"performance-issues",level:3},{value:"Navigation Failures",id:"navigation-failures",level:3},{value:"Summary",id:"summary",level:2}];function p(n){const e={code:"code",h1:"h1",h2:"h2",h3:"h3",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,t.R)(),...n.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(e.h1,{id:"path-planning-with-nav2",children:"Path Planning with Nav2"}),"\n",(0,a.jsx)(e.h2,{id:"overview",children:"Overview"}),"\n",(0,a.jsx)(e.p,{children:"Navigation Stack 2 (Nav2) is the next-generation navigation framework for ROS 2, designed to provide robust, reliable, and flexible path planning and navigation capabilities for mobile robots. When integrated with NVIDIA Isaac, Nav2 can leverage GPU acceleration to enhance path planning performance, making it particularly suitable for humanoid robots that require real-time navigation in complex environments."}),"\n",(0,a.jsx)(e.h2,{id:"learning-objectives",children:"Learning Objectives"}),"\n",(0,a.jsx)(e.p,{children:"By the end of this chapter, you will be able to:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Understand the Nav2 architecture and its components"}),"\n",(0,a.jsx)(e.li,{children:"Configure Nav2 for humanoid robot navigation"}),"\n",(0,a.jsx)(e.li,{children:"Integrate Nav2 with Isaac for GPU-accelerated path planning"}),"\n",(0,a.jsx)(e.li,{children:"Implement custom path planners and controllers"}),"\n",(0,a.jsx)(e.li,{children:"Optimize navigation parameters for humanoid robots"}),"\n",(0,a.jsx)(e.li,{children:"Handle navigation challenges specific to humanoid platforms"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"introduction-to-nav2",children:"Introduction to Nav2"}),"\n",(0,a.jsx)(e.p,{children:"Nav2 represents a complete rewrite of the original ROS Navigation Stack, designed from the ground up for ROS 2. It provides a more robust, flexible, and maintainable framework for robot navigation with support for modern robotics applications including humanoid robots."}),"\n",(0,a.jsx)(e.h3,{id:"nav2-architecture",children:"Nav2 Architecture"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{children:"\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Behavior      \u2502    \u2502   Planning      \u2502    \u2502   Control       \u2502\r\n\u2502   Tree          \u2502    \u2502   & Recovery    \u2502    \u2502   & Estimation  \u2502\r\n\u2502   (Action      \u2502\u25c4\u2500\u2500\u25ba\u2502   (Global &     \u2502\u25c4\u2500\u2500\u25ba\u2502   (Local         \u2502\r\n\u2502   Server)       \u2502    \u2502   Local)        \u2502    \u2502   Planning)     \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502                       \u2502                       \u2502\r\n         \u25bc                       \u25bc                       \u25bc\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502                    Nav2 Core (Plugins & Interfaces)             \u2502\r\n\u2502    (Costmap, TF, Transform, Parameter, Lifecycle Management)   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n         \u2502\r\n         \u25bc\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510    \u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502   Sensors       \u2502    \u2502   Maps &        \u2502    \u2502   Hardware      \u2502\r\n\u2502   (LIDAR,       \u2502    \u2502   Localization  \u2502    \u2502   Interfaces    \u2502\r\n\u2502   Cameras,      \u2502    \u2502   (AMCL, etc.)  \u2502    \u2502   (Diff, Omni,  \u2502\r\n\u2502   IMU, etc.)    \u2502    \u2502                 \u2502    \u2502   Humanoid, etc.)\u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n"})}),"\n",(0,a.jsx)(e.h3,{id:"key-components-of-nav2",children:"Key Components of Nav2"}),"\n",(0,a.jsxs)(e.ol,{children:["\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Navigation System"}),": Main action server coordinating navigation tasks"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Global Planner"}),": Path planning from start to goal"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Local Planner"}),": Real-time trajectory generation and obstacle avoidance"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Recovery Behaviors"}),": Strategies for getting unstuck"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Costmap"}),": Representation of obstacles and navigation space"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Transform System"}),": Coordinate frame management"]}),"\n",(0,a.jsxs)(e.li,{children:[(0,a.jsx)(e.strong,{children:"Lifecycle Management"}),": Component state management"]}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"nav2-configuration-for-humanoid-robots",children:"Nav2 Configuration for Humanoid Robots"}),"\n",(0,a.jsx)(e.h3,{id:"basic-nav2-setup",children:"Basic Nav2 Setup"}),"\n",(0,a.jsx)(e.p,{children:"Nav2 configuration for humanoid robots requires special considerations due to their unique kinematics and dynamics:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-yaml",children:'# navigation_params.yaml\r\namcl:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n    alpha1: 0.2\r\n    alpha2: 0.2\r\n    alpha3: 0.2\r\n    alpha4: 0.2\r\n    alpha5: 0.2\r\n    base_frame_id: "base_footprint"  # Humanoid base frame\r\n    beam_skip_distance: 0.5\r\n    beam_skip_error_threshold: 0.9\r\n    beam_skip_threshold: 0.3\r\n    do_beamskip: false\r\n    global_frame_id: "map"\r\n    lambda_short: 0.1\r\n    laser_likelihood_max_dist: 2.0\r\n    laser_max_range: 10.0\r\n    laser_min_range: -1.0\r\n    laser_model_type: "likelihood_field"\r\n    max_beams: 60\r\n    max_particles: 2000\r\n    min_particles: 500\r\n    odom_frame_id: "odom"\r\n    pf_err: 0.05\r\n    pf_z: 0.5\r\n    recovery_alpha_fast: 0.0\r\n    recovery_alpha_slow: 0.0\r\n    resample_interval: 1\r\n    robot_model_type: "nav2_amcl::DifferentialMotionModel"\r\n    save_pose_rate: 0.5\r\n    sigma_hit: 0.2\r\n    tf_broadcast: true\r\n    transform_tolerance: 1.0\r\n    update_min_a: 0.2\r\n    update_min_d: 0.25\r\n    z_hit: 0.5\r\n    z_max: 0.05\r\n    z_rand: 0.5\r\n    z_short: 0.05\r\n\r\namcl_map_client:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\namcl_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\nbt_navigator:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n    global_frame: "map"\r\n    robot_base_frame: "base_footprint"  # Humanoid base frame\r\n    odom_topic: "odom"\r\n    bt_loop_duration: 10\r\n    default_server_timeout: 20\r\n    # Humanoid-specific behavior tree\r\n    plugin_lib_names:\r\n    - nav2_compute_path_to_pose_action_bt_node\r\n    - nav2_follow_path_action_bt_node\r\n    - nav2_back_up_action_bt_node\r\n    - nav2_spin_action_bt_node\r\n    - nav2_wait_action_bt_node\r\n    - nav2_clear_costmap_service_bt_node\r\n    - nav2_is_stuck_condition_bt_node\r\n    - nav2_goal_reached_condition_bt_node\r\n    - nav2_goal_updated_condition_bt_node\r\n    - nav2_initial_pose_received_condition_bt_node\r\n    - nav2_reinitialize_global_localization_service_bt_node\r\n    - nav2_rate_controller_bt_node\r\n    - nav2_distance_controller_bt_node\r\n    - nav2_speed_controller_bt_node\r\n    - nav2_truncate_path_action_bt_node\r\n    - nav2_goal_updater_node_bt_node\r\n    - nav2_recovery_node_bt_node\r\n    - nav2_pipeline_sequence_bt_node\r\n    - nav2_round_robin_node_bt_node\r\n    - nav2_transform_available_condition_bt_node\r\n    - nav2_time_expired_condition_bt_node\r\n    - nav2_path_expiring_timer_condition\r\n    - nav2_distance_traveled_condition_bt_node\r\n    - nav2_single_trigger_bt_node\r\n    - nav2_is_battery_low_condition_bt_node\r\n    - nav2_navigate_through_poses_action_bt_node\r\n    - nav2_navigate_to_pose_action_bt_node\r\n\r\nbt_navigator_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\ncontroller_server:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n    controller_frequency: 20.0\r\n    min_x_velocity_threshold: 0.001\r\n    min_y_velocity_threshold: 0.5\r\n    min_theta_velocity_threshold: 0.001\r\n    # Humanoid-specific controller\r\n    progress_checker_plugin: "progress_checker"\r\n    goal_checker_plugin: "goal_checker"\r\n    controller_plugins: ["FollowPath"]\r\n\r\n    # Humanoid path follower\r\n    FollowPath:\r\n      plugin: "nav2_mppi_controller::MPPIController"\r\n      time_steps: 50\r\n      model_dt: 0.05\r\n      batch_size: 1000\r\n      vx_std: 0.2\r\n      vy_std: 0.1\r\n      wz_std: 0.3\r\n      vx_max: 0.5\r\n      vx_min: -0.2\r\n      vy_max: 0.3\r\n      wz_max: 0.8\r\n      goal_dist_tol: 0.25\r\n      xy_goal_tolerance: 0.25\r\n      trans_stopped_velocity: 0.25\r\n      shorted_path_angle_thresh: 0.3\r\n      collision_check: true\r\n      collision_cost: 1000.0\r\n      goal_angle_tolerance: 0.25\r\n      heading_lookahead_dist: 0.3\r\n      in_goal_angle_tolerance: true\r\n      oscillation_timeout: 0.0\r\n      oscillation_distance: 0.0\r\n      transform_tolerance: 0.1\r\n      use_vel_scaled_collisions: true\r\n      max_robot_velocity: [0.5, 0.0, 0.8]\r\n      min_robot_velocity: [-0.2, 0.0, -0.8]\r\n      velocity_scaled_collision_checking: true\r\n\r\ncontroller_server_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\nlocal_costmap:\r\n  local_costmap:\r\n    ros__parameters:\r\n      update_frequency: 5.0\r\n      publish_frequency: 2.0\r\n      global_frame: "odom"\r\n      robot_base_frame: "base_footprint"  # Humanoid base frame\r\n      use_sim_time: True\r\n      rolling_window: true\r\n      width: 6\r\n      height: 6\r\n      resolution: 0.05\r\n      # Humanoid-specific inflation\r\n      robot_radius: 0.3  # Humanoid approximate radius\r\n      plugins: ["voxel_layer", "inflation_layer"]\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.5\r\n      voxel_layer:\r\n        plugin: "nav2_costmap_2d::VoxelLayer"\r\n        enabled: True\r\n        publish_voxel_map: True\r\n        origin_z: 0.0\r\n        z_resolution: 0.2\r\n        z_voxels: 8\r\n        max_obstacle_height: 2.0\r\n        mark_threshold: 0\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n  local_costmap_client:\r\n    ros__parameters:\r\n      use_sim_time: True\r\n  local_costmap_rclcpp_node:\r\n    ros__parameters:\r\n      use_sim_time: True\r\n\r\nglobal_costmap:\r\n  global_costmap:\r\n    ros__parameters:\r\n      update_frequency: 1.0\r\n      publish_frequency: 1.0\r\n      global_frame: "map"\r\n      robot_base_frame: "base_footprint"  # Humanoid base frame\r\n      use_sim_time: True\r\n      robot_radius: 0.3  # Humanoid approximate radius\r\n      resolution: 0.05\r\n      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]\r\n      obstacle_layer:\r\n        plugin: "nav2_costmap_2d::ObstacleLayer"\r\n        enabled: True\r\n        observation_sources: scan\r\n        scan:\r\n          topic: /scan\r\n          max_obstacle_height: 2.0\r\n          clearing: True\r\n          marking: True\r\n          data_type: "LaserScan"\r\n          raytrace_max_range: 3.0\r\n          raytrace_min_range: 0.0\r\n          obstacle_max_range: 2.5\r\n          obstacle_min_range: 0.0\r\n      static_layer:\r\n        plugin: "nav2_costmap_2d::StaticLayer"\r\n        map_subscribe_transient_local: True\r\n      inflation_layer:\r\n        plugin: "nav2_costmap_2d::InflationLayer"\r\n        cost_scaling_factor: 3.0\r\n        inflation_radius: 0.5\r\n  global_costmap_client:\r\n    ros__parameters:\r\n      use_sim_time: True\r\n  global_costmap_rclcpp_node:\r\n    ros__parameters:\r\n      use_sim_time: True\r\n\r\nplanner_server:\r\n  ros__parameters:\r\n    expected_planner_frequency: 20.0\r\n    use_sim_time: True\r\n    planner_plugins: ["GridBased"]\r\n    GridBased:\r\n      # GPU-accelerated planner (Isaac integration)\r\n      plugin: "nav2_navfn_planner::NavfnPlanner"\r\n      tolerance: 0.5\r\n      use_astar: false\r\n      allow_unknown: true\r\n\r\nplanner_server_rclcpp_node:\r\n  ros__parameters:\r\n    use_sim_time: True\r\n\r\nrecoveries_server:\r\n  ros__parameters:\r\n    costmap_topic: "local_costmap/costmap_raw"\r\n    footprint_topic: "local_costmap/published_footprint"\r\n    cycle_frequency: 10.0\r\n    recovery_plugins: ["spin", "backup", "wait"]\r\n    recovery_plugin_types: ["nav2_recoveries::Spin", "nav2_recoveries::BackUp", "nav2_recoveries::Wait"]\r\n    spin:\r\n      plugin: "nav2_recoveries::Spin"\r\n      ideal_linear_velocity: 0.0\r\n      ideal_angular_velocity: 1.0\r\n      cmd_yaw_tolerance: 0.1\r\n      steps_to_return_to_normal: 4\r\n      backup:\r\n        plugin: "nav2_recoveries::BackUp"\r\n        sim_granularity: 0.02\r\n        backup_dist: -0.15\r\n        velocity_scaling_factor: 0.1\r\n        wait_for_additional_delay: 0.2\r\n      wait:\r\n        plugin: "nav2_recoveries::Wait"\r\n        wait_duration: 5\r\n\r\nrobot_state_publisher:\r\n  ros__parameters:\r\n    use_sim_time: True\n'})}),"\n",(0,a.jsx)(e.h2,{id:"isaac-integration-with-nav2",children:"Isaac Integration with Nav2"}),"\n",(0,a.jsx)(e.h3,{id:"gpu-accelerated-path-planning",children:"GPU-Accelerated Path Planning"}),"\n",(0,a.jsx)(e.p,{children:"Isaac provides GPU acceleration for Nav2 components, particularly for computationally intensive path planning algorithms:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom nav_msgs.msg import Path\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom sensor_msgs.msg import LaserScan\r\nimport numpy as np\r\nimport cupy as cp  # CUDA-accelerated NumPy\r\n\r\nclass IsaacNav2Planner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'isaac_nav2_planner\')\r\n\r\n        # Subscribe to goal and sensor data\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped, \'/goal_pose\', self.goal_callback, 10)\r\n        self.laser_sub = self.create_subscription(\r\n            LaserScan, \'/scan\', self.laser_callback, 10)\r\n\r\n        # Publisher for planned path\r\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\r\n\r\n        # Initialize GPU context\r\n        self.gpu_available = self.initialize_gpu()\r\n\r\n        # Costmap representation\r\n        self.costmap = None\r\n        self.map_resolution = 0.05\r\n        self.map_origin = [0, 0]\r\n\r\n        # A* path planning with GPU acceleration\r\n        self.a_star_planner = IsaacAStarPlanner(self.gpu_available)\r\n\r\n    def initialize_gpu(self):\r\n        """Initialize GPU context for path planning"""\r\n        try:\r\n            if cp.cuda.is_available():\r\n                self.get_logger().info(\'GPU acceleration enabled for path planning\')\r\n                return True\r\n            else:\r\n                self.get_logger().warn(\'GPU not available, using CPU fallback\')\r\n                return False\r\n        except Exception as e:\r\n            self.get_logger().warn(f\'GPU initialization failed: {e}\')\r\n            return False\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle navigation goal with GPU-accelerated planning"""\r\n        # Convert goal to map coordinates\r\n        goal_x = int((msg.pose.position.x - self.map_origin[0]) / self.map_resolution)\r\n        goal_y = int((msg.pose.position.y - self.map_origin[1]) / self.map_resolution)\r\n\r\n        # Plan path using GPU-accelerated A*\r\n        if self.costmap is not None:\r\n            path = self.a_star_planner.plan_path(\r\n                self.costmap, (0, 0), (goal_x, goal_y)\r\n            )\r\n            self.publish_path(path, msg.header)\r\n\r\n    def laser_callback(self, msg):\r\n        """Update costmap based on laser data"""\r\n        # Process laser scan to update costmap\r\n        self.update_costmap(msg)\r\n\r\n    def update_costmap(self, laser_msg):\r\n        """Update costmap with laser scan data"""\r\n        # Convert laser scan to occupancy grid using GPU acceleration\r\n        if self.gpu_available:\r\n            self.costmap = self.update_costmap_gpu(laser_msg)\r\n        else:\r\n            self.costmap = self.update_costmap_cpu(laser_msg)\r\n\r\n    def update_costmap_gpu(self, laser_msg):\r\n        """GPU-accelerated costmap update"""\r\n        # Convert laser ranges to GPU array\r\n        ranges_gpu = cp.array(laser_msg.ranges, dtype=cp.float32)\r\n\r\n        # Process ranges to identify obstacles\r\n        valid_ranges = cp.isfinite(ranges_gpu)\r\n        obstacle_distances = ranges_gpu[valid_ranges]\r\n        obstacle_angles = cp.linspace(\r\n            laser_msg.angle_min, laser_msg.angle_max, len(ranges_gpu)\r\n        )[valid_ranges]\r\n\r\n        # Convert to Cartesian coordinates\r\n        obstacle_x = obstacle_distances * cp.cos(obstacle_angles)\r\n        obstacle_y = obstacle_distances * cp.sin(obstacle_angles)\r\n\r\n        # Update costmap with obstacle information\r\n        # This is a simplified example - real implementation would be more complex\r\n        costmap = cp.zeros((100, 100), dtype=cp.uint8)\r\n\r\n        # Convert obstacle coordinates to costmap indices\r\n        obs_x_indices = cp.array((obstacle_x / self.map_resolution).astype(cp.int32))\r\n        obs_y_indices = cp.array((obstacle_y / self.map_resolution).astype(cp.int32))\r\n\r\n        # Clamp indices to valid range\r\n        obs_x_indices = cp.clip(obs_x_indices, 0, costmap.shape[1] - 1)\r\n        obs_y_indices = cp.clip(obs_y_indices, 0, costmap.shape[0] - 1)\r\n\r\n        # Mark obstacles in costmap\r\n        costmap[obs_y_indices, obs_x_indices] = 255\r\n\r\n        return cp.asnumpy(costmap)\r\n\r\n    def update_costmap_cpu(self, laser_msg):\r\n        """CPU-based costmap update (fallback)"""\r\n        import math\r\n\r\n        # Convert laser scan to occupancy grid\r\n        ranges = np.array(laser_msg.ranges)\r\n        valid_ranges = np.isfinite(ranges)\r\n\r\n        obstacle_distances = ranges[valid_ranges]\r\n        angle_increment = laser_msg.angle_increment\r\n        start_angle = laser_msg.angle_min\r\n\r\n        obstacle_angles = start_angle + np.arange(len(ranges))[valid_ranges] * angle_increment\r\n\r\n        # Convert to Cartesian coordinates\r\n        obstacle_x = obstacle_distances * np.cos(obstacle_angles)\r\n        obstacle_y = obstacle_distances * np.sin(obstacle_angles)\r\n\r\n        # Update costmap (simplified)\r\n        costmap = np.zeros((100, 100), dtype=np.uint8)\r\n\r\n        obs_x_indices = np.clip((obstacle_x / self.map_resolution).astype(int), 0, costmap.shape[1] - 1)\r\n        obs_y_indices = np.clip((obstacle_y / self.map_resolution).astype(int), 0, costmap.shape[0] - 1)\r\n\r\n        costmap[obs_y_indices, obs_x_indices] = 255\r\n\r\n        return costmap\r\n\r\n    def publish_path(self, path, header):\r\n        """Publish planned path"""\r\n        if path is None or len(path) == 0:\r\n            return\r\n\r\n        path_msg = Path()\r\n        path_msg.header = header\r\n        path_msg.header.frame_id = \'map\'\r\n\r\n        for point in path:\r\n            pose = PoseStamped()\r\n            pose.pose.position.x = point[0] * self.map_resolution + self.map_origin[0]\r\n            pose.pose.position.y = point[1] * self.map_resolution + self.map_origin[1]\r\n            pose.pose.position.z = 0.0\r\n            path_msg.poses.append(pose)\r\n\r\n        self.path_pub.publish(path_msg)\r\n\r\nclass IsaacAStarPlanner:\r\n    def __init__(self, gpu_available):\r\n        self.gpu_available = gpu_available\r\n\r\n    def plan_path(self, costmap, start, goal):\r\n        """Plan path using GPU-accelerated A* algorithm"""\r\n        if self.gpu_available:\r\n            return self.plan_path_gpu(costmap, start, goal)\r\n        else:\r\n            return self.plan_path_cpu(costmap, start, goal)\r\n\r\n    def plan_path_gpu(self, costmap, start, goal):\r\n        """GPU-accelerated A* path planning"""\r\n        try:\r\n            # Transfer costmap to GPU\r\n            costmap_gpu = cp.array(costmap, dtype=cp.uint8)\r\n\r\n            # Initialize open set with start position\r\n            open_set = cp.array([start[0], start[1]], dtype=cp.int32).reshape(1, 2)\r\n            closed_set = cp.zeros_like(costmap_gpu, dtype=cp.bool_)\r\n\r\n            # Initialize g_score and f_score\r\n            g_score = cp.full(costmap_gpu.shape, cp.inf, dtype=cp.float32)\r\n            f_score = cp.full(costmap_gpu.shape, cp.inf, dtype=cp.float32)\r\n\r\n            g_score[start[1], start[0]] = 0\r\n            f_score[start[1], start[0]] = self.heuristic_gpu(start, goal)\r\n\r\n            # A* algorithm with GPU acceleration\r\n            path = self.a_star_algorithm_gpu(costmap_gpu, start, goal, open_set, closed_set, g_score, f_score)\r\n\r\n            return path\r\n        except Exception as e:\r\n            print(f"GPU path planning failed: {e}, falling back to CPU")\r\n            return self.plan_path_cpu(costmap, start, goal)\r\n\r\n    def heuristic_gpu(self, pos1, pos2):\r\n        """GPU-accelerated heuristic calculation (Manhattan distance)"""\r\n        return cp.abs(pos1[0] - pos2[0]) + cp.abs(pos1[1] - pos2[1])\r\n\r\n    def a_star_algorithm_gpu(self, costmap, start, goal, open_set, closed_set, g_score, f_score):\r\n        """GPU implementation of A* algorithm (simplified)"""\r\n        # This is a conceptual implementation\r\n        # Real GPU-accelerated A* would require more complex data structures\r\n        # and parallel processing techniques\r\n\r\n        # For demonstration, returning a simple path\r\n        path = []\r\n        current = start\r\n        while current != goal:\r\n            # In a real implementation, this would use GPU-parallel A* search\r\n            path.append(current)\r\n            # Move towards goal (simplified)\r\n            if current[0] < goal[0]:\r\n                current = (current[0] + 1, current[1])\r\n            elif current[0] > goal[0]:\r\n                current = (current[0] - 1, current[1])\r\n            elif current[1] < goal[1]:\r\n                current = (current[0], current[1] + 1)\r\n            else:\r\n                current = (current[0], current[1] - 1)\r\n\r\n            if len(path) > 1000:  # Prevent infinite loops\r\n                break\r\n\r\n        path.append(goal)\r\n        return path\r\n\r\n    def plan_path_cpu(self, costmap, start, goal):\r\n        """CPU-based A* path planning (fallback)"""\r\n        import heapq\r\n\r\n        def heuristic(pos1, pos2):\r\n            return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])\r\n\r\n        def get_neighbors(pos):\r\n            neighbors = []\r\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\r\n                nx, ny = pos[0] + dx, pos[1] + dy\r\n                if 0 <= nx < costmap.shape[1] and 0 <= ny < costmap.shape[0]:\r\n                    if costmap[ny, nx] < 255:  # Not an obstacle\r\n                        neighbors.append((nx, ny))\r\n            return neighbors\r\n\r\n        open_set = [(0, start)]\r\n        came_from = {}\r\n        g_score = {start: 0}\r\n        f_score = {start: heuristic(start, goal)}\r\n\r\n        while open_set:\r\n            current = heapq.heappop(open_set)[1]\r\n\r\n            if current == goal:\r\n                # Reconstruct path\r\n                path = []\r\n                while current in came_from:\r\n                    path.append(current)\r\n                    current = came_from[current]\r\n                path.append(start)\r\n                path.reverse()\r\n                return path\r\n\r\n            for neighbor in get_neighbors(current):\r\n                tentative_g_score = g_score[current] + 1\r\n\r\n                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:\r\n                    came_from[neighbor] = current\r\n                    g_score[neighbor] = tentative_g_score\r\n                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)\r\n                    heapq.heappush(open_set, (f_score[neighbor], neighbor))\r\n\r\n        return None  # No path found\n'})}),"\n",(0,a.jsx)(e.h2,{id:"humanoid-specific-navigation-considerations",children:"Humanoid-Specific Navigation Considerations"}),"\n",(0,a.jsx)(e.h3,{id:"bipedal-locomotion-integration",children:"Bipedal Locomotion Integration"}),"\n",(0,a.jsx)(e.p,{children:"Humanoid robots require special navigation planning due to their bipedal nature:"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import Twist, PoseStamped\r\nfrom nav_msgs.msg import Path\r\nfrom std_msgs.msg import Bool\r\nimport numpy as np\r\n\r\nclass HumanoidNavigationController(Node):\r\n    def __init__(self):\r\n        super().__init__(\'humanoid_navigation_controller\')\r\n\r\n        # Publishers and subscribers\r\n        self.cmd_vel_pub = self.create_publisher(Twist, \'/cmd_vel\', 10)\r\n        self.path_sub = self.create_subscription(Path, \'/plan\', self.path_callback, 10)\r\n        self.goal_sub = self.create_subscription(PoseStamped, \'/goal_pose\', self.goal_callback, 10)\r\n\r\n        # Humanoid-specific parameters\r\n        self.step_size = 0.3  # Distance per step\r\n        self.step_frequency = 2.0  # Steps per second\r\n        self.max_turn_rate = 0.5  # Maximum turning rate (rad/s)\r\n        self.min_turn_radius = 0.5  # Minimum turn radius (m)\r\n\r\n        # Navigation state\r\n        self.current_path = []\r\n        self.current_waypoint_idx = 0\r\n        self.navigation_active = False\r\n        self.balance_maintained = True\r\n\r\n        # Balance monitoring\r\n        self.balance_sub = self.create_subscription(Bool, \'/balance_status\', self.balance_callback, 10)\r\n\r\n        # Timer for navigation execution\r\n        self.nav_timer = self.create_timer(0.1, self.execute_navigation)\r\n\r\n    def balance_callback(self, msg):\r\n        """Update balance status"""\r\n        self.balance_maintained = msg.data\r\n\r\n    def path_callback(self, msg):\r\n        """Receive planned path"""\r\n        self.current_path = [(pose.pose.position.x, pose.pose.position.y) for pose in msg.poses]\r\n        self.current_waypoint_idx = 0\r\n        self.navigation_active = True\r\n\r\n    def goal_callback(self, msg):\r\n        """Handle new navigation goal"""\r\n        # Goal handling would trigger path planning\r\n        pass\r\n\r\n    def execute_navigation(self):\r\n        """Execute navigation with humanoid-specific constraints"""\r\n        if not self.navigation_active or not self.balance_maintained:\r\n            # Stop if navigation is not active or balance is compromised\r\n            self.stop_robot()\r\n            return\r\n\r\n        if not self.current_path or self.current_waypoint_idx >= len(self.current_path):\r\n            # Path completed\r\n            self.navigation_active = False\r\n            self.stop_robot()\r\n            return\r\n\r\n        # Get current and next waypoints\r\n        current_pos = self.get_current_position()  # Would come from localization\r\n        target_pos = self.current_path[self.current_waypoint_idx]\r\n\r\n        # Calculate desired velocity based on humanoid locomotion constraints\r\n        cmd_vel = self.calculate_humanoid_velocity(current_pos, target_pos)\r\n\r\n        # Publish command\r\n        self.cmd_vel_pub.publish(cmd_vel)\r\n\r\n        # Check if reached current waypoint\r\n        distance_to_waypoint = np.sqrt(\r\n            (current_pos[0] - target_pos[0])**2 +\r\n            (current_pos[1] - target_pos[1])**2\r\n        )\r\n\r\n        if distance_to_waypoint < 0.2:  # Waypoint tolerance\r\n            self.current_waypoint_idx += 1\r\n\r\n    def calculate_humanoid_velocity(self, current_pos, target_pos):\r\n        """Calculate velocity commands for humanoid locomotion"""\r\n        # Calculate desired direction\r\n        dx = target_pos[0] - current_pos[0]\r\n        dy = target_pos[1] - current_pos[1]\r\n        distance = np.sqrt(dx**2 + dy**2)\r\n\r\n        # Calculate desired angle\r\n        desired_angle = np.arctan2(dy, dx)\r\n\r\n        # Get current orientation (would come from localization)\r\n        current_angle = 0.0  # Placeholder\r\n\r\n        # Calculate angular error\r\n        angle_error = desired_angle - current_angle\r\n        # Normalize angle to [-pi, pi]\r\n        angle_error = ((angle_error + np.pi) % (2 * np.pi)) - np.pi\r\n\r\n        cmd_vel = Twist()\r\n\r\n        # Linear velocity based on distance and humanoid constraints\r\n        if distance > 0.1:  # If not close to target\r\n            # Scale linear velocity based on distance (slow down when close)\r\n            linear_vel = min(0.3, distance * 0.5)  # Max 0.3 m/s\r\n            cmd_vel.linear.x = linear_vel\r\n        else:\r\n            cmd_vel.linear.x = 0.0\r\n\r\n        # Angular velocity based on angle error and humanoid constraints\r\n        if abs(angle_error) > 0.1:  # If significant angle error\r\n            angular_vel = max(-self.max_turn_rate, min(self.max_turn_rate, angle_error * 1.0))\r\n            cmd_vel.angular.z = angular_vel\r\n        else:\r\n            cmd_vel.angular.z = 0.0\r\n\r\n        # Apply humanoid-specific constraints\r\n        cmd_vel = self.apply_humanoid_constraints(cmd_vel)\r\n\r\n        return cmd_vel\r\n\r\n    def apply_humanoid_constraints(self, cmd_vel):\r\n        """Apply humanoid-specific velocity constraints"""\r\n        # Limit velocities based on humanoid capabilities\r\n        cmd_vel.linear.x = max(-0.2, min(0.5, cmd_vel.linear.x))  # -0.2 to 0.5 m/s\r\n        cmd_vel.angular.z = max(-0.5, min(0.5, cmd_vel.angular.z))  # -0.5 to 0.5 rad/s\r\n\r\n        return cmd_vel\r\n\r\n    def get_current_position(self):\r\n        """Get current robot position from localization"""\r\n        # This would interface with localization system\r\n        # For now, return placeholder\r\n        return (0.0, 0.0)\r\n\r\n    def stop_robot(self):\r\n        """Stop robot motion"""\r\n        cmd_vel = Twist()\r\n        cmd_vel.linear.x = 0.0\r\n        cmd_vel.angular.z = 0.0\r\n        self.cmd_vel_pub.publish(cmd_vel)\n'})}),"\n",(0,a.jsx)(e.h2,{id:"advanced-path-planning-algorithms",children:"Advanced Path Planning Algorithms"}),"\n",(0,a.jsx)(e.h3,{id:"gpu-accelerated-dijkstras-algorithm",children:"GPU-Accelerated Dijkstra's Algorithm"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import cupy as cp\r\nimport numpy as np\r\nfrom collections import defaultdict\r\n\r\nclass GPUDijkstraPlanner:\r\n    def __init__(self, gpu_available=True):\r\n        self.gpu_available = gpu_available\r\n\r\n    def plan_path(self, costmap, start, goal):\r\n        """Plan path using GPU-accelerated Dijkstra\'s algorithm"""\r\n        if self.gpu_available:\r\n            return self.dijkstra_gpu(costmap, start, goal)\r\n        else:\r\n            return self.dijkstra_cpu(costmap, start, goal)\r\n\r\n    def dijkstra_gpu(self, costmap, start, goal):\r\n        """GPU-accelerated Dijkstra\'s algorithm"""\r\n        try:\r\n            # Transfer costmap to GPU\r\n            costmap_gpu = cp.array(costmap, dtype=cp.float32)\r\n\r\n            height, width = costmap_gpu.shape\r\n\r\n            # Initialize distances\r\n            distances = cp.full((height, width), cp.inf, dtype=cp.float32)\r\n            distances[start[1], start[0]] = 0\r\n\r\n            # Previous nodes for path reconstruction\r\n            previous = cp.full((height, width, 2), -1, dtype=cp.int32)\r\n\r\n            # Visited nodes\r\n            visited = cp.zeros((height, width), dtype=cp.bool_)\r\n\r\n            # Priority queue simulation using arrays\r\n            unvisited = cp.ones((height, width), dtype=cp.bool_)\r\n\r\n            current = cp.array(start, dtype=cp.int32)\r\n\r\n            while cp.any(unvisited):\r\n                # Find unvisited node with minimum distance\r\n                unvisited_distances = cp.where(visited, cp.inf, distances)\r\n                min_idx = cp.unravel_index(cp.argmin(unvisited_distances), distances.shape)\r\n\r\n                if min_idx[1] == goal[0] and min_idx[0] == goal[1]:\r\n                    break  # Reached goal\r\n\r\n                current = cp.array(min_idx[::-1], dtype=cp.int32)  # [x, y] format\r\n\r\n                if distances[current[1], current[0]] == cp.inf:\r\n                    break  # No path exists\r\n\r\n                # Mark as visited\r\n                visited[current[1], current[0]] = True\r\n                unvisited[current[1], current[0]] = False\r\n\r\n                # Check neighbors\r\n                neighbors = self.get_neighbors_gpu(current, height, width)\r\n\r\n                for neighbor in neighbors:\r\n                    if visited[neighbor[1], neighbor[0]]:\r\n                        continue\r\n\r\n                    # Calculate tentative distance\r\n                    cost = costmap_gpu[neighbor[1], neighbor[0]] / 255.0 + 1.0\r\n                    tentative_distance = distances[current[1], current[0]] + cost\r\n\r\n                    if tentative_distance < distances[neighbor[1], neighbor[0]]:\r\n                        distances[neighbor[1], neighbor[0]] = tentative_distance\r\n                        previous[neighbor[1], neighbor[0]] = current\r\n\r\n            # Reconstruct path\r\n            path = self.reconstruct_path_gpu(previous, start, goal)\r\n            return path\r\n\r\n        except Exception as e:\r\n            print(f"GPU Dijkstra failed: {e}, falling back to CPU")\r\n            return self.dijkstra_cpu(costmap, start, goal)\r\n\r\n    def get_neighbors_gpu(self, pos, height, width):\r\n        """Get valid neighbors for GPU processing"""\r\n        neighbors = []\r\n        x, y = pos[0], pos[1]\r\n\r\n        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:\r\n            nx, ny = x + dx, y + dy\r\n            if 0 <= nx < width and 0 <= ny < height:\r\n                neighbors.append((nx, ny))\r\n\r\n        return neighbors\r\n\r\n    def reconstruct_path_gpu(self, previous, start, goal):\r\n        """Reconstruct path from previous nodes"""\r\n        path = []\r\n        current = cp.array(goal, dtype=cp.int32)\r\n\r\n        while not (current[0] == start[0] and current[1] == start[1]):\r\n            path.append((int(current[0].get()), int(current[1].get())))\r\n\r\n            prev_node = previous[current[1], current[0]]\r\n            if prev_node[0] == -1:\r\n                # No path exists\r\n                return None\r\n\r\n            current = prev_node\r\n\r\n        path.append(start)\r\n        path.reverse()\r\n        return path\r\n\r\n    def dijkstra_cpu(self, costmap, start, goal):\r\n        """CPU-based Dijkstra\'s algorithm (fallback)"""\r\n        import heapq\r\n\r\n        def get_neighbors(pos):\r\n            neighbors = []\r\n            x, y = pos\r\n            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:\r\n                nx, ny = x + dx, y + dy\r\n                if 0 <= nx < costmap.shape[1] and 0 <= ny < costmap.shape[0]:\r\n                    if costmap[ny, nx] < 255:  # Not an obstacle\r\n                        neighbors.append((nx, ny))\r\n            return neighbors\r\n\r\n        distances = defaultdict(lambda: float(\'inf\'))\r\n        distances[start] = 0\r\n        previous = {}\r\n\r\n        pq = [(0, start)]\r\n        visited = set()\r\n\r\n        while pq:\r\n            current_dist, current = heapq.heappop(pq)\r\n\r\n            if current in visited:\r\n                continue\r\n\r\n            visited.add(current)\r\n\r\n            if current == goal:\r\n                break\r\n\r\n            for neighbor in get_neighbors(current):\r\n                if neighbor in visited:\r\n                    continue\r\n\r\n                cost = costmap[neighbor[1], neighbor[0]] / 255.0 + 1.0\r\n                distance = current_dist + cost\r\n\r\n                if distance < distances[neighbor]:\r\n                    distances[neighbor] = distance\r\n                    previous[neighbor] = current\r\n                    heapq.heappush(pq, (distance, neighbor))\r\n\r\n        # Reconstruct path\r\n        path = []\r\n        current = goal\r\n        while current in previous:\r\n            path.append(current)\r\n            current = previous[current]\r\n        path.append(start)\r\n        path.reverse()\r\n\r\n        return path if path[0] == start else None\n'})}),"\n",(0,a.jsx)(e.h2,{id:"behavior-trees-for-navigation",children:"Behavior Trees for Navigation"}),"\n",(0,a.jsx)(e.h3,{id:"nav2-behavior-tree-integration",children:"Nav2 Behavior Tree Integration"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom geometry_msgs.msg import PoseStamped\r\nfrom nav2_msgs.action import NavigateToPose\r\nfrom rclpy.action import ActionClient\r\nimport time\r\n\r\nclass Nav2BehaviorManager(Node):\r\n    def __init__(self):\r\n        super().__init__(\'nav2_behavior_manager\')\r\n\r\n        # Action client for NavigateToPose\r\n        self.nav_client = ActionClient(self, NavigateToPose, \'navigate_to_pose\')\r\n\r\n        # Navigation state\r\n        self.navigation_goal = None\r\n        self.navigation_active = False\r\n\r\n    def send_navigation_goal(self, x, y, theta=0.0):\r\n        """Send navigation goal to Nav2"""\r\n        # Wait for action server\r\n        self.nav_client.wait_for_server()\r\n\r\n        # Create goal message\r\n        goal_msg = NavigateToPose.Goal()\r\n        goal_msg.pose.header.frame_id = \'map\'\r\n        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()\r\n        goal_msg.pose.pose.position.x = x\r\n        goal_msg.pose.pose.position.y = y\r\n        goal_msg.pose.pose.position.z = 0.0\r\n\r\n        # Convert theta to quaternion\r\n        import math\r\n        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)\r\n        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)\r\n\r\n        # Send goal\r\n        future = self.nav_client.send_goal_async(goal_msg)\r\n        future.add_done_callback(self.goal_response_callback)\r\n\r\n        self.navigation_active = True\r\n        self.get_logger().info(f\'Sent navigation goal to ({x}, {y})\')\r\n\r\n    def goal_response_callback(self, future):\r\n        """Handle goal response"""\r\n        goal_handle = future.result()\r\n        if not goal_handle.accepted:\r\n            self.get_logger().info(\'Goal rejected\')\r\n            self.navigation_active = False\r\n            return\r\n\r\n        self.get_logger().info(\'Goal accepted\')\r\n        result_future = goal_handle.get_result_async()\r\n        result_future.add_done_callback(self.get_result_callback)\r\n\r\n    def get_result_callback(self, future):\r\n        """Handle navigation result"""\r\n        result = future.result().result\r\n        self.get_logger().info(f\'Navigation completed with result: {result}\')\r\n        self.navigation_active = False\r\n\r\n    def cancel_navigation(self):\r\n        """Cancel active navigation"""\r\n        if self.navigation_active:\r\n            # Cancel the goal\r\n            self.nav_client._cancel_goal_async(self.navigation_goal)\r\n            self.navigation_active = False\r\n            self.get_logger().info(\'Navigation cancelled\')\r\n\r\nclass HumanoidNav2Integrator(Node):\r\n    def __init__(self):\r\n        super().__init__(\'humanoid_nav2_integrator\')\r\n\r\n        # Initialize behavior manager\r\n        self.behavior_manager = Nav2BehaviorManager()\r\n\r\n        # Initialize path planner with Isaac integration\r\n        self.path_planner = IsaacNav2Planner(gpu_available=True)\r\n\r\n        # Timer for behavior execution\r\n        self.behavior_timer = self.create_timer(1.0, self.execute_behavior)\r\n\r\n        # Behavior state\r\n        self.behavior_state = \'IDLE\'\r\n        self.navigation_queue = []\r\n\r\n    def execute_behavior(self):\r\n        """Execute navigation behaviors"""\r\n        if self.behavior_state == \'IDLE\':\r\n            # Check if there are navigation goals in queue\r\n            if self.navigation_queue:\r\n                goal = self.navigation_queue.pop(0)\r\n                self.behavior_manager.send_navigation_goal(goal[0], goal[1], goal[2])\r\n                self.behavior_state = \'NAVIGATING\'\r\n\r\n        elif self.behavior_state == \'NAVIGATING\':\r\n            # Check if navigation is still active\r\n            if not self.behavior_manager.navigation_active:\r\n                self.behavior_state = \'IDLE\'\r\n\r\n    def add_navigation_goal(self, x, y, theta=0.0):\r\n        """Add navigation goal to queue"""\r\n        self.navigation_queue.append((x, y, theta))\r\n        self.get_logger().info(f\'Added navigation goal to queue: ({x}, {y}, {theta})\')\r\n\r\n    def set_waypoints(self, waypoints):\r\n        """Set multiple waypoints for navigation"""\r\n        for wp in waypoints:\r\n            self.add_navigation_goal(wp[0], wp[1], wp[2] if len(wp) > 2 else 0.0)\r\n\r\ndef main(args=None):\r\n    rclpy.init(args=args)\r\n\r\n    # Create integrator node\r\n    integrator = HumanoidNav2Integrator()\r\n\r\n    # Example: Set some waypoints\r\n    waypoints = [\r\n        (1.0, 1.0, 0.0),\r\n        (2.0, 2.0, 1.57),\r\n        (3.0, 1.0, 3.14),\r\n        (4.0, 0.0, -1.57)\r\n    ]\r\n    integrator.set_waypoints(waypoints)\r\n\r\n    try:\r\n        rclpy.spin(integrator)\r\n    except KeyboardInterrupt:\r\n        pass\r\n    finally:\r\n        integrator.destroy_node()\r\n        rclpy.shutdown()\r\n\r\nif __name__ == \'__main__\':\r\n    main()\n'})}),"\n",(0,a.jsx)(e.h2,{id:"performance-optimization",children:"Performance Optimization"}),"\n",(0,a.jsx)(e.h3,{id:"gpu-resource-management",children:"GPU Resource Management"}),"\n",(0,a.jsx)(e.pre,{children:(0,a.jsx)(e.code,{className:"language-python",children:'import rclpy\r\nfrom rclpy.node import Node\r\nfrom std_msgs.msg import Float32\r\nimport cupy as cp\r\nimport threading\r\nimport time\r\n\r\nclass GPUResourceManager(Node):\r\n    def __init__(self):\r\n        super().__init__(\'gpu_resource_manager\')\r\n\r\n        # GPU resource monitoring\r\n        self.gpu_util_pub = self.create_publisher(Float32, \'/gpu_utilization\', 10)\r\n        self.gpu_memory_pub = self.create_publisher(Float32, \'/gpu_memory_usage\', 10)\r\n\r\n        # Resource management\r\n        self.active_planners = 0\r\n        self.max_planners = 4  # Limit concurrent GPU-accelerated planners\r\n        self.gpu_lock = threading.Lock()\r\n\r\n        # Timer for resource monitoring\r\n        self.resource_timer = self.create_timer(0.5, self.monitor_resources)\r\n\r\n    def monitor_resources(self):\r\n        """Monitor GPU resources"""\r\n        try:\r\n            # Get GPU utilization (conceptual - would use pynvml)\r\n            gpu_util = self.get_gpu_utilization()\r\n            gpu_memory = self.get_gpu_memory_usage()\r\n\r\n            # Publish resource usage\r\n            util_msg = Float32()\r\n            util_msg.data = gpu_util\r\n            self.gpu_util_pub.publish(util_msg)\r\n\r\n            memory_msg = Float32()\r\n            memory_msg.data = gpu_memory\r\n            self.gpu_memory_pub.publish(memory_msg)\r\n\r\n        except Exception as e:\r\n            self.get_logger().warn(f\'GPU monitoring failed: {e}\')\r\n\r\n    def get_gpu_utilization(self):\r\n        """Get GPU utilization percentage"""\r\n        # This would interface with NVIDIA management library\r\n        # For demonstration, return simulated value\r\n        return 45.0\r\n\r\n    def get_gpu_memory_usage(self):\r\n        """Get GPU memory usage percentage"""\r\n        # This would interface with NVIDIA management library\r\n        # For demonstration, return simulated value\r\n        return 60.0\r\n\r\n    def acquire_gpu_resources(self):\r\n        """Acquire GPU resources for planning"""\r\n        with self.gpu_lock:\r\n            if self.active_planners < self.max_planners:\r\n                self.active_planners += 1\r\n                return True\r\n            else:\r\n                return False\r\n\r\n    def release_gpu_resources(self):\r\n        """Release GPU resources after planning"""\r\n        with self.gpu_lock:\r\n            if self.active_planners > 0:\r\n                self.active_planners -= 1\r\n\r\nclass OptimizedIsaacNav2Planner(Node):\r\n    def __init__(self):\r\n        super().__init__(\'optimized_isaac_nav2_planner\')\r\n\r\n        # Initialize GPU resource manager\r\n        self.gpu_manager = GPUResourceManager()\r\n\r\n        # Subscribe to navigation requests\r\n        self.goal_sub = self.create_subscription(\r\n            PoseStamped, \'/goal_pose\', self.optimized_goal_callback, 10)\r\n\r\n        # Publisher for planned paths\r\n        self.path_pub = self.create_publisher(Path, \'/plan\', 10)\r\n\r\n    def optimized_goal_callback(self, msg):\r\n        """Handle navigation goal with resource optimization"""\r\n        # Try to acquire GPU resources\r\n        if self.gpu_manager.acquire_gpu_resources():\r\n            try:\r\n                # Perform GPU-accelerated path planning\r\n                self.gpu_path_planning(msg)\r\n            finally:\r\n                # Always release resources\r\n                self.gpu_manager.release_gpu_resources()\r\n        else:\r\n            # Fallback to CPU planning if GPU resources unavailable\r\n            self.cpu_path_planning(msg)\r\n\r\n    def gpu_path_planning(self, goal_msg):\r\n        """GPU-accelerated path planning with resource management"""\r\n        self.get_logger().info(\'Using GPU for path planning\')\r\n\r\n        # Check GPU availability\r\n        if not cp.cuda.is_available():\r\n            self.get_logger().warn(\'GPU not available, using CPU fallback\')\r\n            self.cpu_path_planning(goal_msg)\r\n            return\r\n\r\n        # Perform GPU-accelerated planning\r\n        # This would use the GPU-accelerated planners implemented earlier\r\n        pass\r\n\r\n    def cpu_path_planning(self, goal_msg):\r\n        """CPU-based path planning (fallback)"""\r\n        self.get_logger().info(\'Using CPU for path planning\')\r\n\r\n        # Perform CPU-based planning\r\n        # This would use traditional path planning algorithms\r\n        pass\n'})}),"\n",(0,a.jsx)(e.h2,{id:"best-practices-for-nav2-with-isaac",children:"Best Practices for Nav2 with Isaac"}),"\n",(0,a.jsx)(e.h3,{id:"1-configuration-optimization",children:"1. Configuration Optimization"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Tune costmap parameters for humanoid size and dynamics"}),"\n",(0,a.jsx)(e.li,{children:"Adjust inflation radius based on robot dimensions"}),"\n",(0,a.jsx)(e.li,{children:"Configure appropriate sensor fusion for humanoid perception"}),"\n",(0,a.jsx)(e.li,{children:"Set realistic velocity and acceleration limits"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"2-performance-considerations",children:"2. Performance Considerations"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Use GPU acceleration for computationally intensive tasks"}),"\n",(0,a.jsx)(e.li,{children:"Implement proper resource management"}),"\n",(0,a.jsx)(e.li,{children:"Monitor system performance during navigation"}),"\n",(0,a.jsx)(e.li,{children:"Optimize map resolution for your use case"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"3-safety-and-reliability",children:"3. Safety and Reliability"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Implement proper recovery behaviors"}),"\n",(0,a.jsx)(e.li,{children:"Use appropriate safety margins in costmaps"}),"\n",(0,a.jsx)(e.li,{children:"Monitor robot balance during navigation"}),"\n",(0,a.jsx)(e.li,{children:"Implement emergency stop capabilities"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"4-testing-and-validation",children:"4. Testing and Validation"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Test navigation in simulation before real deployment"}),"\n",(0,a.jsx)(e.li,{children:"Validate path planning in various environments"}),"\n",(0,a.jsx)(e.li,{children:"Test edge cases and failure scenarios"}),"\n",(0,a.jsx)(e.li,{children:"Monitor navigation performance metrics"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"troubleshooting-common-issues",children:"Troubleshooting Common Issues"}),"\n",(0,a.jsx)(e.h3,{id:"path-planning-problems",children:"Path Planning Problems"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Check costmap configuration and inflation parameters"}),"\n",(0,a.jsx)(e.li,{children:"Verify sensor data quality and frequency"}),"\n",(0,a.jsx)(e.li,{children:"Ensure proper TF tree configuration"}),"\n",(0,a.jsx)(e.li,{children:"Validate map quality and resolution"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"performance-issues",children:"Performance Issues"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Monitor GPU utilization and memory usage"}),"\n",(0,a.jsx)(e.li,{children:"Check for CPU bottlenecks in sensor processing"}),"\n",(0,a.jsx)(e.li,{children:"Verify adequate update frequencies"}),"\n",(0,a.jsx)(e.li,{children:"Profile navigation components for optimization"}),"\n"]}),"\n",(0,a.jsx)(e.h3,{id:"navigation-failures",children:"Navigation Failures"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"Review recovery behavior configuration"}),"\n",(0,a.jsx)(e.li,{children:"Check obstacle detection and costmap updates"}),"\n",(0,a.jsx)(e.li,{children:"Validate localization accuracy"}),"\n",(0,a.jsx)(e.li,{children:"Verify robot kinematic constraints"}),"\n"]}),"\n",(0,a.jsx)(e.h2,{id:"summary",children:"Summary"}),"\n",(0,a.jsx)(e.p,{children:"Nav2 provides a robust and flexible navigation framework that, when integrated with Isaac's GPU acceleration capabilities, offers powerful path planning and navigation for humanoid robots. The combination enables real-time processing of complex navigation tasks while maintaining the flexibility and reliability required for autonomous humanoid navigation."}),"\n",(0,a.jsx)(e.p,{children:"Key aspects of Nav2 with Isaac integration include:"}),"\n",(0,a.jsxs)(e.ul,{children:["\n",(0,a.jsx)(e.li,{children:"GPU-accelerated path planning algorithms for improved performance"}),"\n",(0,a.jsx)(e.li,{children:"Humanoid-specific navigation constraints and behaviors"}),"\n",(0,a.jsx)(e.li,{children:"Advanced behavior tree integration for complex navigation tasks"}),"\n",(0,a.jsx)(e.li,{children:"Resource management for optimal GPU utilization"}),"\n"]}),"\n",(0,a.jsx)(e.p,{children:"The successful implementation of Nav2 with Isaac requires careful configuration of both the navigation parameters and the GPU acceleration components, ensuring that the system is optimized for the specific requirements of humanoid robot navigation."}),"\n",(0,a.jsx)(e.p,{children:"In the next chapter, we'll explore reinforcement learning and sim-to-real transfer techniques in the context of Isaac, examining how these approaches can be applied to humanoid robot control and learning."})]})}function _(n={}){const{wrapper:e}={...(0,t.R)(),...n.components};return e?(0,a.jsx)(e,{...n,children:(0,a.jsx)(p,{...n})}):p(n)}},8453:(n,e,r)=>{r.d(e,{R:()=>o,x:()=>s});var a=r(6540);const t={},i=a.createContext(t);function o(n){const e=a.useContext(i);return a.useMemo(function(){return"function"==typeof n?n(e):{...e,...n}},[e,n])}function s(n){let e;return e=n.disableParentContext?"function"==typeof n.components?n.components(t):n.components||t:o(n.components),a.createElement(i.Provider,{value:e},n.children)}}}]);