---
sidebar_position: 14
title: 'Chapter 14: Path Planning with Nav2'
---

# Path Planning with Nav2

## Overview

Navigation Stack 2 (Nav2) is the next-generation navigation framework for ROS 2, designed to provide robust, reliable, and flexible path planning and navigation capabilities for mobile robots. When integrated with NVIDIA Isaac, Nav2 can leverage GPU acceleration to enhance path planning performance, making it particularly suitable for humanoid robots that require real-time navigation in complex environments.

## Learning Objectives

By the end of this chapter, you will be able to:
- Understand the Nav2 architecture and its components
- Configure Nav2 for humanoid robot navigation
- Integrate Nav2 with Isaac for GPU-accelerated path planning
- Implement custom path planners and controllers
- Optimize navigation parameters for humanoid robots
- Handle navigation challenges specific to humanoid platforms

## Introduction to Nav2

Nav2 represents a complete rewrite of the original ROS Navigation Stack, designed from the ground up for ROS 2. It provides a more robust, flexible, and maintainable framework for robot navigation with support for modern robotics applications including humanoid robots.

### Nav2 Architecture

```
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Behavior      │    │   Planning      │    │   Control       │
│   Tree          │    │   & Recovery    │    │   & Estimation  │
│   (Action      │◄──►│   (Global &     │◄──►│   (Local         │
│   Server)       │    │   Local)        │    │   Planning)     │
└─────────────────┘    └─────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────────────────────────────────────────────────────┐
│                    Nav2 Core (Plugins & Interfaces)             │
│    (Costmap, TF, Transform, Parameter, Lifecycle Management)   │
└─────────────────────────────────────────────────────────────────┘
         │
         ▼
┌─────────────────┐    ┌─────────────────┐    ┌─────────────────┐
│   Sensors       │    │   Maps &        │    │   Hardware      │
│   (LIDAR,       │    │   Localization  │    │   Interfaces    │
│   Cameras,      │    │   (AMCL, etc.)  │    │   (Diff, Omni,  │
│   IMU, etc.)    │    │                 │    │   Humanoid, etc.)│
└─────────────────┘    └─────────────────┘    └─────────────────┘
```

### Key Components of Nav2

1. **Navigation System**: Main action server coordinating navigation tasks
2. **Global Planner**: Path planning from start to goal
3. **Local Planner**: Real-time trajectory generation and obstacle avoidance
4. **Recovery Behaviors**: Strategies for getting unstuck
5. **Costmap**: Representation of obstacles and navigation space
6. **Transform System**: Coordinate frame management
7. **Lifecycle Management**: Component state management

## Nav2 Configuration for Humanoid Robots

### Basic Nav2 Setup

Nav2 configuration for humanoid robots requires special considerations due to their unique kinematics and dynamics:

```yaml
# navigation_params.yaml
amcl:
  ros__parameters:
    use_sim_time: True
    alpha1: 0.2
    alpha2: 0.2
    alpha3: 0.2
    alpha4: 0.2
    alpha5: 0.2
    base_frame_id: "base_footprint"  # Humanoid base frame
    beam_skip_distance: 0.5
    beam_skip_error_threshold: 0.9
    beam_skip_threshold: 0.3
    do_beamskip: false
    global_frame_id: "map"
    lambda_short: 0.1
    laser_likelihood_max_dist: 2.0
    laser_max_range: 10.0
    laser_min_range: -1.0
    laser_model_type: "likelihood_field"
    max_beams: 60
    max_particles: 2000
    min_particles: 500
    odom_frame_id: "odom"
    pf_err: 0.05
    pf_z: 0.5
    recovery_alpha_fast: 0.0
    recovery_alpha_slow: 0.0
    resample_interval: 1
    robot_model_type: "nav2_amcl::DifferentialMotionModel"
    save_pose_rate: 0.5
    sigma_hit: 0.2
    tf_broadcast: true
    transform_tolerance: 1.0
    update_min_a: 0.2
    update_min_d: 0.25
    z_hit: 0.5
    z_max: 0.05
    z_rand: 0.5
    z_short: 0.05

amcl_map_client:
  ros__parameters:
    use_sim_time: True

amcl_rclcpp_node:
  ros__parameters:
    use_sim_time: True

bt_navigator:
  ros__parameters:
    use_sim_time: True
    global_frame: "map"
    robot_base_frame: "base_footprint"  # Humanoid base frame
    odom_topic: "odom"
    bt_loop_duration: 10
    default_server_timeout: 20
    # Humanoid-specific behavior tree
    plugin_lib_names:
    - nav2_compute_path_to_pose_action_bt_node
    - nav2_follow_path_action_bt_node
    - nav2_back_up_action_bt_node
    - nav2_spin_action_bt_node
    - nav2_wait_action_bt_node
    - nav2_clear_costmap_service_bt_node
    - nav2_is_stuck_condition_bt_node
    - nav2_goal_reached_condition_bt_node
    - nav2_goal_updated_condition_bt_node
    - nav2_initial_pose_received_condition_bt_node
    - nav2_reinitialize_global_localization_service_bt_node
    - nav2_rate_controller_bt_node
    - nav2_distance_controller_bt_node
    - nav2_speed_controller_bt_node
    - nav2_truncate_path_action_bt_node
    - nav2_goal_updater_node_bt_node
    - nav2_recovery_node_bt_node
    - nav2_pipeline_sequence_bt_node
    - nav2_round_robin_node_bt_node
    - nav2_transform_available_condition_bt_node
    - nav2_time_expired_condition_bt_node
    - nav2_path_expiring_timer_condition
    - nav2_distance_traveled_condition_bt_node
    - nav2_single_trigger_bt_node
    - nav2_is_battery_low_condition_bt_node
    - nav2_navigate_through_poses_action_bt_node
    - nav2_navigate_to_pose_action_bt_node

bt_navigator_rclcpp_node:
  ros__parameters:
    use_sim_time: True

controller_server:
  ros__parameters:
    use_sim_time: True
    controller_frequency: 20.0
    min_x_velocity_threshold: 0.001
    min_y_velocity_threshold: 0.5
    min_theta_velocity_threshold: 0.001
    # Humanoid-specific controller
    progress_checker_plugin: "progress_checker"
    goal_checker_plugin: "goal_checker"
    controller_plugins: ["FollowPath"]

    # Humanoid path follower
    FollowPath:
      plugin: "nav2_mppi_controller::MPPIController"
      time_steps: 50
      model_dt: 0.05
      batch_size: 1000
      vx_std: 0.2
      vy_std: 0.1
      wz_std: 0.3
      vx_max: 0.5
      vx_min: -0.2
      vy_max: 0.3
      wz_max: 0.8
      goal_dist_tol: 0.25
      xy_goal_tolerance: 0.25
      trans_stopped_velocity: 0.25
      shorted_path_angle_thresh: 0.3
      collision_check: true
      collision_cost: 1000.0
      goal_angle_tolerance: 0.25
      heading_lookahead_dist: 0.3
      in_goal_angle_tolerance: true
      oscillation_timeout: 0.0
      oscillation_distance: 0.0
      transform_tolerance: 0.1
      use_vel_scaled_collisions: true
      max_robot_velocity: [0.5, 0.0, 0.8]
      min_robot_velocity: [-0.2, 0.0, -0.8]
      velocity_scaled_collision_checking: true

controller_server_rclcpp_node:
  ros__parameters:
    use_sim_time: True

local_costmap:
  local_costmap:
    ros__parameters:
      update_frequency: 5.0
      publish_frequency: 2.0
      global_frame: "odom"
      robot_base_frame: "base_footprint"  # Humanoid base frame
      use_sim_time: True
      rolling_window: true
      width: 6
      height: 6
      resolution: 0.05
      # Humanoid-specific inflation
      robot_radius: 0.3  # Humanoid approximate radius
      plugins: ["voxel_layer", "inflation_layer"]
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.5
      voxel_layer:
        plugin: "nav2_costmap_2d::VoxelLayer"
        enabled: True
        publish_voxel_map: True
        origin_z: 0.0
        z_resolution: 0.2
        z_voxels: 8
        max_obstacle_height: 2.0
        mark_threshold: 0
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
  local_costmap_client:
    ros__parameters:
      use_sim_time: True
  local_costmap_rclcpp_node:
    ros__parameters:
      use_sim_time: True

global_costmap:
  global_costmap:
    ros__parameters:
      update_frequency: 1.0
      publish_frequency: 1.0
      global_frame: "map"
      robot_base_frame: "base_footprint"  # Humanoid base frame
      use_sim_time: True
      robot_radius: 0.3  # Humanoid approximate radius
      resolution: 0.05
      plugins: ["static_layer", "obstacle_layer", "inflation_layer"]
      obstacle_layer:
        plugin: "nav2_costmap_2d::ObstacleLayer"
        enabled: True
        observation_sources: scan
        scan:
          topic: /scan
          max_obstacle_height: 2.0
          clearing: True
          marking: True
          data_type: "LaserScan"
          raytrace_max_range: 3.0
          raytrace_min_range: 0.0
          obstacle_max_range: 2.5
          obstacle_min_range: 0.0
      static_layer:
        plugin: "nav2_costmap_2d::StaticLayer"
        map_subscribe_transient_local: True
      inflation_layer:
        plugin: "nav2_costmap_2d::InflationLayer"
        cost_scaling_factor: 3.0
        inflation_radius: 0.5
  global_costmap_client:
    ros__parameters:
      use_sim_time: True
  global_costmap_rclcpp_node:
    ros__parameters:
      use_sim_time: True

planner_server:
  ros__parameters:
    expected_planner_frequency: 20.0
    use_sim_time: True
    planner_plugins: ["GridBased"]
    GridBased:
      # GPU-accelerated planner (Isaac integration)
      plugin: "nav2_navfn_planner::NavfnPlanner"
      tolerance: 0.5
      use_astar: false
      allow_unknown: true

planner_server_rclcpp_node:
  ros__parameters:
    use_sim_time: True

recoveries_server:
  ros__parameters:
    costmap_topic: "local_costmap/costmap_raw"
    footprint_topic: "local_costmap/published_footprint"
    cycle_frequency: 10.0
    recovery_plugins: ["spin", "backup", "wait"]
    recovery_plugin_types: ["nav2_recoveries::Spin", "nav2_recoveries::BackUp", "nav2_recoveries::Wait"]
    spin:
      plugin: "nav2_recoveries::Spin"
      ideal_linear_velocity: 0.0
      ideal_angular_velocity: 1.0
      cmd_yaw_tolerance: 0.1
      steps_to_return_to_normal: 4
      backup:
        plugin: "nav2_recoveries::BackUp"
        sim_granularity: 0.02
        backup_dist: -0.15
        velocity_scaling_factor: 0.1
        wait_for_additional_delay: 0.2
      wait:
        plugin: "nav2_recoveries::Wait"
        wait_duration: 5

robot_state_publisher:
  ros__parameters:
    use_sim_time: True
```

## Isaac Integration with Nav2

### GPU-Accelerated Path Planning

Isaac provides GPU acceleration for Nav2 components, particularly for computationally intensive path planning algorithms:

```python
import rclpy
from rclpy.node import Node
from nav_msgs.msg import Path
from geometry_msgs.msg import PoseStamped
from sensor_msgs.msg import LaserScan
import numpy as np
import cupy as cp  # CUDA-accelerated NumPy

class IsaacNav2Planner(Node):
    def __init__(self):
        super().__init__('isaac_nav2_planner')

        # Subscribe to goal and sensor data
        self.goal_sub = self.create_subscription(
            PoseStamped, '/goal_pose', self.goal_callback, 10)
        self.laser_sub = self.create_subscription(
            LaserScan, '/scan', self.laser_callback, 10)

        # Publisher for planned path
        self.path_pub = self.create_publisher(Path, '/plan', 10)

        # Initialize GPU context
        self.gpu_available = self.initialize_gpu()

        # Costmap representation
        self.costmap = None
        self.map_resolution = 0.05
        self.map_origin = [0, 0]

        # A* path planning with GPU acceleration
        self.a_star_planner = IsaacAStarPlanner(self.gpu_available)

    def initialize_gpu(self):
        """Initialize GPU context for path planning"""
        try:
            if cp.cuda.is_available():
                self.get_logger().info('GPU acceleration enabled for path planning')
                return True
            else:
                self.get_logger().warn('GPU not available, using CPU fallback')
                return False
        except Exception as e:
            self.get_logger().warn(f'GPU initialization failed: {e}')
            return False

    def goal_callback(self, msg):
        """Handle navigation goal with GPU-accelerated planning"""
        # Convert goal to map coordinates
        goal_x = int((msg.pose.position.x - self.map_origin[0]) / self.map_resolution)
        goal_y = int((msg.pose.position.y - self.map_origin[1]) / self.map_resolution)

        # Plan path using GPU-accelerated A*
        if self.costmap is not None:
            path = self.a_star_planner.plan_path(
                self.costmap, (0, 0), (goal_x, goal_y)
            )
            self.publish_path(path, msg.header)

    def laser_callback(self, msg):
        """Update costmap based on laser data"""
        # Process laser scan to update costmap
        self.update_costmap(msg)

    def update_costmap(self, laser_msg):
        """Update costmap with laser scan data"""
        # Convert laser scan to occupancy grid using GPU acceleration
        if self.gpu_available:
            self.costmap = self.update_costmap_gpu(laser_msg)
        else:
            self.costmap = self.update_costmap_cpu(laser_msg)

    def update_costmap_gpu(self, laser_msg):
        """GPU-accelerated costmap update"""
        # Convert laser ranges to GPU array
        ranges_gpu = cp.array(laser_msg.ranges, dtype=cp.float32)

        # Process ranges to identify obstacles
        valid_ranges = cp.isfinite(ranges_gpu)
        obstacle_distances = ranges_gpu[valid_ranges]
        obstacle_angles = cp.linspace(
            laser_msg.angle_min, laser_msg.angle_max, len(ranges_gpu)
        )[valid_ranges]

        # Convert to Cartesian coordinates
        obstacle_x = obstacle_distances * cp.cos(obstacle_angles)
        obstacle_y = obstacle_distances * cp.sin(obstacle_angles)

        # Update costmap with obstacle information
        # This is a simplified example - real implementation would be more complex
        costmap = cp.zeros((100, 100), dtype=cp.uint8)

        # Convert obstacle coordinates to costmap indices
        obs_x_indices = cp.array((obstacle_x / self.map_resolution).astype(cp.int32))
        obs_y_indices = cp.array((obstacle_y / self.map_resolution).astype(cp.int32))

        # Clamp indices to valid range
        obs_x_indices = cp.clip(obs_x_indices, 0, costmap.shape[1] - 1)
        obs_y_indices = cp.clip(obs_y_indices, 0, costmap.shape[0] - 1)

        # Mark obstacles in costmap
        costmap[obs_y_indices, obs_x_indices] = 255

        return cp.asnumpy(costmap)

    def update_costmap_cpu(self, laser_msg):
        """CPU-based costmap update (fallback)"""
        import math

        # Convert laser scan to occupancy grid
        ranges = np.array(laser_msg.ranges)
        valid_ranges = np.isfinite(ranges)

        obstacle_distances = ranges[valid_ranges]
        angle_increment = laser_msg.angle_increment
        start_angle = laser_msg.angle_min

        obstacle_angles = start_angle + np.arange(len(ranges))[valid_ranges] * angle_increment

        # Convert to Cartesian coordinates
        obstacle_x = obstacle_distances * np.cos(obstacle_angles)
        obstacle_y = obstacle_distances * np.sin(obstacle_angles)

        # Update costmap (simplified)
        costmap = np.zeros((100, 100), dtype=np.uint8)

        obs_x_indices = np.clip((obstacle_x / self.map_resolution).astype(int), 0, costmap.shape[1] - 1)
        obs_y_indices = np.clip((obstacle_y / self.map_resolution).astype(int), 0, costmap.shape[0] - 1)

        costmap[obs_y_indices, obs_x_indices] = 255

        return costmap

    def publish_path(self, path, header):
        """Publish planned path"""
        if path is None or len(path) == 0:
            return

        path_msg = Path()
        path_msg.header = header
        path_msg.header.frame_id = 'map'

        for point in path:
            pose = PoseStamped()
            pose.pose.position.x = point[0] * self.map_resolution + self.map_origin[0]
            pose.pose.position.y = point[1] * self.map_resolution + self.map_origin[1]
            pose.pose.position.z = 0.0
            path_msg.poses.append(pose)

        self.path_pub.publish(path_msg)

class IsaacAStarPlanner:
    def __init__(self, gpu_available):
        self.gpu_available = gpu_available

    def plan_path(self, costmap, start, goal):
        """Plan path using GPU-accelerated A* algorithm"""
        if self.gpu_available:
            return self.plan_path_gpu(costmap, start, goal)
        else:
            return self.plan_path_cpu(costmap, start, goal)

    def plan_path_gpu(self, costmap, start, goal):
        """GPU-accelerated A* path planning"""
        try:
            # Transfer costmap to GPU
            costmap_gpu = cp.array(costmap, dtype=cp.uint8)

            # Initialize open set with start position
            open_set = cp.array([start[0], start[1]], dtype=cp.int32).reshape(1, 2)
            closed_set = cp.zeros_like(costmap_gpu, dtype=cp.bool_)

            # Initialize g_score and f_score
            g_score = cp.full(costmap_gpu.shape, cp.inf, dtype=cp.float32)
            f_score = cp.full(costmap_gpu.shape, cp.inf, dtype=cp.float32)

            g_score[start[1], start[0]] = 0
            f_score[start[1], start[0]] = self.heuristic_gpu(start, goal)

            # A* algorithm with GPU acceleration
            path = self.a_star_algorithm_gpu(costmap_gpu, start, goal, open_set, closed_set, g_score, f_score)

            return path
        except Exception as e:
            print(f"GPU path planning failed: {e}, falling back to CPU")
            return self.plan_path_cpu(costmap, start, goal)

    def heuristic_gpu(self, pos1, pos2):
        """GPU-accelerated heuristic calculation (Manhattan distance)"""
        return cp.abs(pos1[0] - pos2[0]) + cp.abs(pos1[1] - pos2[1])

    def a_star_algorithm_gpu(self, costmap, start, goal, open_set, closed_set, g_score, f_score):
        """GPU implementation of A* algorithm (simplified)"""
        # This is a conceptual implementation
        # Real GPU-accelerated A* would require more complex data structures
        # and parallel processing techniques

        # For demonstration, returning a simple path
        path = []
        current = start
        while current != goal:
            # In a real implementation, this would use GPU-parallel A* search
            path.append(current)
            # Move towards goal (simplified)
            if current[0] < goal[0]:
                current = (current[0] + 1, current[1])
            elif current[0] > goal[0]:
                current = (current[0] - 1, current[1])
            elif current[1] < goal[1]:
                current = (current[0], current[1] + 1)
            else:
                current = (current[0], current[1] - 1)

            if len(path) > 1000:  # Prevent infinite loops
                break

        path.append(goal)
        return path

    def plan_path_cpu(self, costmap, start, goal):
        """CPU-based A* path planning (fallback)"""
        import heapq

        def heuristic(pos1, pos2):
            return abs(pos1[0] - pos2[0]) + abs(pos1[1] - pos2[1])

        def get_neighbors(pos):
            neighbors = []
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = pos[0] + dx, pos[1] + dy
                if 0 <= nx < costmap.shape[1] and 0 <= ny < costmap.shape[0]:
                    if costmap[ny, nx] < 255:  # Not an obstacle
                        neighbors.append((nx, ny))
            return neighbors

        open_set = [(0, start)]
        came_from = {}
        g_score = {start: 0}
        f_score = {start: heuristic(start, goal)}

        while open_set:
            current = heapq.heappop(open_set)[1]

            if current == goal:
                # Reconstruct path
                path = []
                while current in came_from:
                    path.append(current)
                    current = came_from[current]
                path.append(start)
                path.reverse()
                return path

            for neighbor in get_neighbors(current):
                tentative_g_score = g_score[current] + 1

                if neighbor not in g_score or tentative_g_score < g_score[neighbor]:
                    came_from[neighbor] = current
                    g_score[neighbor] = tentative_g_score
                    f_score[neighbor] = tentative_g_score + heuristic(neighbor, goal)
                    heapq.heappush(open_set, (f_score[neighbor], neighbor))

        return None  # No path found
```

## Humanoid-Specific Navigation Considerations

### Bipedal Locomotion Integration

Humanoid robots require special navigation planning due to their bipedal nature:

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import Twist, PoseStamped
from nav_msgs.msg import Path
from std_msgs.msg import Bool
import numpy as np

class HumanoidNavigationController(Node):
    def __init__(self):
        super().__init__('humanoid_navigation_controller')

        # Publishers and subscribers
        self.cmd_vel_pub = self.create_publisher(Twist, '/cmd_vel', 10)
        self.path_sub = self.create_subscription(Path, '/plan', self.path_callback, 10)
        self.goal_sub = self.create_subscription(PoseStamped, '/goal_pose', self.goal_callback, 10)

        # Humanoid-specific parameters
        self.step_size = 0.3  # Distance per step
        self.step_frequency = 2.0  # Steps per second
        self.max_turn_rate = 0.5  # Maximum turning rate (rad/s)
        self.min_turn_radius = 0.5  # Minimum turn radius (m)

        # Navigation state
        self.current_path = []
        self.current_waypoint_idx = 0
        self.navigation_active = False
        self.balance_maintained = True

        # Balance monitoring
        self.balance_sub = self.create_subscription(Bool, '/balance_status', self.balance_callback, 10)

        # Timer for navigation execution
        self.nav_timer = self.create_timer(0.1, self.execute_navigation)

    def balance_callback(self, msg):
        """Update balance status"""
        self.balance_maintained = msg.data

    def path_callback(self, msg):
        """Receive planned path"""
        self.current_path = [(pose.pose.position.x, pose.pose.position.y) for pose in msg.poses]
        self.current_waypoint_idx = 0
        self.navigation_active = True

    def goal_callback(self, msg):
        """Handle new navigation goal"""
        # Goal handling would trigger path planning
        pass

    def execute_navigation(self):
        """Execute navigation with humanoid-specific constraints"""
        if not self.navigation_active or not self.balance_maintained:
            # Stop if navigation is not active or balance is compromised
            self.stop_robot()
            return

        if not self.current_path or self.current_waypoint_idx >= len(self.current_path):
            # Path completed
            self.navigation_active = False
            self.stop_robot()
            return

        # Get current and next waypoints
        current_pos = self.get_current_position()  # Would come from localization
        target_pos = self.current_path[self.current_waypoint_idx]

        # Calculate desired velocity based on humanoid locomotion constraints
        cmd_vel = self.calculate_humanoid_velocity(current_pos, target_pos)

        # Publish command
        self.cmd_vel_pub.publish(cmd_vel)

        # Check if reached current waypoint
        distance_to_waypoint = np.sqrt(
            (current_pos[0] - target_pos[0])**2 +
            (current_pos[1] - target_pos[1])**2
        )

        if distance_to_waypoint < 0.2:  # Waypoint tolerance
            self.current_waypoint_idx += 1

    def calculate_humanoid_velocity(self, current_pos, target_pos):
        """Calculate velocity commands for humanoid locomotion"""
        # Calculate desired direction
        dx = target_pos[0] - current_pos[0]
        dy = target_pos[1] - current_pos[1]
        distance = np.sqrt(dx**2 + dy**2)

        # Calculate desired angle
        desired_angle = np.arctan2(dy, dx)

        # Get current orientation (would come from localization)
        current_angle = 0.0  # Placeholder

        # Calculate angular error
        angle_error = desired_angle - current_angle
        # Normalize angle to [-pi, pi]
        angle_error = ((angle_error + np.pi) % (2 * np.pi)) - np.pi

        cmd_vel = Twist()

        # Linear velocity based on distance and humanoid constraints
        if distance > 0.1:  # If not close to target
            # Scale linear velocity based on distance (slow down when close)
            linear_vel = min(0.3, distance * 0.5)  # Max 0.3 m/s
            cmd_vel.linear.x = linear_vel
        else:
            cmd_vel.linear.x = 0.0

        # Angular velocity based on angle error and humanoid constraints
        if abs(angle_error) > 0.1:  # If significant angle error
            angular_vel = max(-self.max_turn_rate, min(self.max_turn_rate, angle_error * 1.0))
            cmd_vel.angular.z = angular_vel
        else:
            cmd_vel.angular.z = 0.0

        # Apply humanoid-specific constraints
        cmd_vel = self.apply_humanoid_constraints(cmd_vel)

        return cmd_vel

    def apply_humanoid_constraints(self, cmd_vel):
        """Apply humanoid-specific velocity constraints"""
        # Limit velocities based on humanoid capabilities
        cmd_vel.linear.x = max(-0.2, min(0.5, cmd_vel.linear.x))  # -0.2 to 0.5 m/s
        cmd_vel.angular.z = max(-0.5, min(0.5, cmd_vel.angular.z))  # -0.5 to 0.5 rad/s

        return cmd_vel

    def get_current_position(self):
        """Get current robot position from localization"""
        # This would interface with localization system
        # For now, return placeholder
        return (0.0, 0.0)

    def stop_robot(self):
        """Stop robot motion"""
        cmd_vel = Twist()
        cmd_vel.linear.x = 0.0
        cmd_vel.angular.z = 0.0
        self.cmd_vel_pub.publish(cmd_vel)
```

## Advanced Path Planning Algorithms

### GPU-Accelerated Dijkstra's Algorithm

```python
import cupy as cp
import numpy as np
from collections import defaultdict

class GPUDijkstraPlanner:
    def __init__(self, gpu_available=True):
        self.gpu_available = gpu_available

    def plan_path(self, costmap, start, goal):
        """Plan path using GPU-accelerated Dijkstra's algorithm"""
        if self.gpu_available:
            return self.dijkstra_gpu(costmap, start, goal)
        else:
            return self.dijkstra_cpu(costmap, start, goal)

    def dijkstra_gpu(self, costmap, start, goal):
        """GPU-accelerated Dijkstra's algorithm"""
        try:
            # Transfer costmap to GPU
            costmap_gpu = cp.array(costmap, dtype=cp.float32)

            height, width = costmap_gpu.shape

            # Initialize distances
            distances = cp.full((height, width), cp.inf, dtype=cp.float32)
            distances[start[1], start[0]] = 0

            # Previous nodes for path reconstruction
            previous = cp.full((height, width, 2), -1, dtype=cp.int32)

            # Visited nodes
            visited = cp.zeros((height, width), dtype=cp.bool_)

            # Priority queue simulation using arrays
            unvisited = cp.ones((height, width), dtype=cp.bool_)

            current = cp.array(start, dtype=cp.int32)

            while cp.any(unvisited):
                # Find unvisited node with minimum distance
                unvisited_distances = cp.where(visited, cp.inf, distances)
                min_idx = cp.unravel_index(cp.argmin(unvisited_distances), distances.shape)

                if min_idx[1] == goal[0] and min_idx[0] == goal[1]:
                    break  # Reached goal

                current = cp.array(min_idx[::-1], dtype=cp.int32)  # [x, y] format

                if distances[current[1], current[0]] == cp.inf:
                    break  # No path exists

                # Mark as visited
                visited[current[1], current[0]] = True
                unvisited[current[1], current[0]] = False

                # Check neighbors
                neighbors = self.get_neighbors_gpu(current, height, width)

                for neighbor in neighbors:
                    if visited[neighbor[1], neighbor[0]]:
                        continue

                    # Calculate tentative distance
                    cost = costmap_gpu[neighbor[1], neighbor[0]] / 255.0 + 1.0
                    tentative_distance = distances[current[1], current[0]] + cost

                    if tentative_distance < distances[neighbor[1], neighbor[0]]:
                        distances[neighbor[1], neighbor[0]] = tentative_distance
                        previous[neighbor[1], neighbor[0]] = current

            # Reconstruct path
            path = self.reconstruct_path_gpu(previous, start, goal)
            return path

        except Exception as e:
            print(f"GPU Dijkstra failed: {e}, falling back to CPU")
            return self.dijkstra_cpu(costmap, start, goal)

    def get_neighbors_gpu(self, pos, height, width):
        """Get valid neighbors for GPU processing"""
        neighbors = []
        x, y = pos[0], pos[1]

        for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1), (-1, -1), (-1, 1), (1, -1), (1, 1)]:
            nx, ny = x + dx, y + dy
            if 0 <= nx < width and 0 <= ny < height:
                neighbors.append((nx, ny))

        return neighbors

    def reconstruct_path_gpu(self, previous, start, goal):
        """Reconstruct path from previous nodes"""
        path = []
        current = cp.array(goal, dtype=cp.int32)

        while not (current[0] == start[0] and current[1] == start[1]):
            path.append((int(current[0].get()), int(current[1].get())))

            prev_node = previous[current[1], current[0]]
            if prev_node[0] == -1:
                # No path exists
                return None

            current = prev_node

        path.append(start)
        path.reverse()
        return path

    def dijkstra_cpu(self, costmap, start, goal):
        """CPU-based Dijkstra's algorithm (fallback)"""
        import heapq

        def get_neighbors(pos):
            neighbors = []
            x, y = pos
            for dx, dy in [(-1, 0), (1, 0), (0, -1), (0, 1)]:
                nx, ny = x + dx, y + dy
                if 0 <= nx < costmap.shape[1] and 0 <= ny < costmap.shape[0]:
                    if costmap[ny, nx] < 255:  # Not an obstacle
                        neighbors.append((nx, ny))
            return neighbors

        distances = defaultdict(lambda: float('inf'))
        distances[start] = 0
        previous = {}

        pq = [(0, start)]
        visited = set()

        while pq:
            current_dist, current = heapq.heappop(pq)

            if current in visited:
                continue

            visited.add(current)

            if current == goal:
                break

            for neighbor in get_neighbors(current):
                if neighbor in visited:
                    continue

                cost = costmap[neighbor[1], neighbor[0]] / 255.0 + 1.0
                distance = current_dist + cost

                if distance < distances[neighbor]:
                    distances[neighbor] = distance
                    previous[neighbor] = current
                    heapq.heappush(pq, (distance, neighbor))

        # Reconstruct path
        path = []
        current = goal
        while current in previous:
            path.append(current)
            current = previous[current]
        path.append(start)
        path.reverse()

        return path if path[0] == start else None
```

## Behavior Trees for Navigation

### Nav2 Behavior Tree Integration

```python
import rclpy
from rclpy.node import Node
from geometry_msgs.msg import PoseStamped
from nav2_msgs.action import NavigateToPose
from rclpy.action import ActionClient
import time

class Nav2BehaviorManager(Node):
    def __init__(self):
        super().__init__('nav2_behavior_manager')

        # Action client for NavigateToPose
        self.nav_client = ActionClient(self, NavigateToPose, 'navigate_to_pose')

        # Navigation state
        self.navigation_goal = None
        self.navigation_active = False

    def send_navigation_goal(self, x, y, theta=0.0):
        """Send navigation goal to Nav2"""
        # Wait for action server
        self.nav_client.wait_for_server()

        # Create goal message
        goal_msg = NavigateToPose.Goal()
        goal_msg.pose.header.frame_id = 'map'
        goal_msg.pose.header.stamp = self.get_clock().now().to_msg()
        goal_msg.pose.pose.position.x = x
        goal_msg.pose.pose.position.y = y
        goal_msg.pose.pose.position.z = 0.0

        # Convert theta to quaternion
        import math
        goal_msg.pose.pose.orientation.z = math.sin(theta / 2.0)
        goal_msg.pose.pose.orientation.w = math.cos(theta / 2.0)

        # Send goal
        future = self.nav_client.send_goal_async(goal_msg)
        future.add_done_callback(self.goal_response_callback)

        self.navigation_active = True
        self.get_logger().info(f'Sent navigation goal to ({x}, {y})')

    def goal_response_callback(self, future):
        """Handle goal response"""
        goal_handle = future.result()
        if not goal_handle.accepted:
            self.get_logger().info('Goal rejected')
            self.navigation_active = False
            return

        self.get_logger().info('Goal accepted')
        result_future = goal_handle.get_result_async()
        result_future.add_done_callback(self.get_result_callback)

    def get_result_callback(self, future):
        """Handle navigation result"""
        result = future.result().result
        self.get_logger().info(f'Navigation completed with result: {result}')
        self.navigation_active = False

    def cancel_navigation(self):
        """Cancel active navigation"""
        if self.navigation_active:
            # Cancel the goal
            self.nav_client._cancel_goal_async(self.navigation_goal)
            self.navigation_active = False
            self.get_logger().info('Navigation cancelled')

class HumanoidNav2Integrator(Node):
    def __init__(self):
        super().__init__('humanoid_nav2_integrator')

        # Initialize behavior manager
        self.behavior_manager = Nav2BehaviorManager()

        # Initialize path planner with Isaac integration
        self.path_planner = IsaacNav2Planner(gpu_available=True)

        # Timer for behavior execution
        self.behavior_timer = self.create_timer(1.0, self.execute_behavior)

        # Behavior state
        self.behavior_state = 'IDLE'
        self.navigation_queue = []

    def execute_behavior(self):
        """Execute navigation behaviors"""
        if self.behavior_state == 'IDLE':
            # Check if there are navigation goals in queue
            if self.navigation_queue:
                goal = self.navigation_queue.pop(0)
                self.behavior_manager.send_navigation_goal(goal[0], goal[1], goal[2])
                self.behavior_state = 'NAVIGATING'

        elif self.behavior_state == 'NAVIGATING':
            # Check if navigation is still active
            if not self.behavior_manager.navigation_active:
                self.behavior_state = 'IDLE'

    def add_navigation_goal(self, x, y, theta=0.0):
        """Add navigation goal to queue"""
        self.navigation_queue.append((x, y, theta))
        self.get_logger().info(f'Added navigation goal to queue: ({x}, {y}, {theta})')

    def set_waypoints(self, waypoints):
        """Set multiple waypoints for navigation"""
        for wp in waypoints:
            self.add_navigation_goal(wp[0], wp[1], wp[2] if len(wp) > 2 else 0.0)

def main(args=None):
    rclpy.init(args=args)

    # Create integrator node
    integrator = HumanoidNav2Integrator()

    # Example: Set some waypoints
    waypoints = [
        (1.0, 1.0, 0.0),
        (2.0, 2.0, 1.57),
        (3.0, 1.0, 3.14),
        (4.0, 0.0, -1.57)
    ]
    integrator.set_waypoints(waypoints)

    try:
        rclpy.spin(integrator)
    except KeyboardInterrupt:
        pass
    finally:
        integrator.destroy_node()
        rclpy.shutdown()

if __name__ == '__main__':
    main()
```

## Performance Optimization

### GPU Resource Management

```python
import rclpy
from rclpy.node import Node
from std_msgs.msg import Float32
import cupy as cp
import threading
import time

class GPUResourceManager(Node):
    def __init__(self):
        super().__init__('gpu_resource_manager')

        # GPU resource monitoring
        self.gpu_util_pub = self.create_publisher(Float32, '/gpu_utilization', 10)
        self.gpu_memory_pub = self.create_publisher(Float32, '/gpu_memory_usage', 10)

        # Resource management
        self.active_planners = 0
        self.max_planners = 4  # Limit concurrent GPU-accelerated planners
        self.gpu_lock = threading.Lock()

        # Timer for resource monitoring
        self.resource_timer = self.create_timer(0.5, self.monitor_resources)

    def monitor_resources(self):
        """Monitor GPU resources"""
        try:
            # Get GPU utilization (conceptual - would use pynvml)
            gpu_util = self.get_gpu_utilization()
            gpu_memory = self.get_gpu_memory_usage()

            # Publish resource usage
            util_msg = Float32()
            util_msg.data = gpu_util
            self.gpu_util_pub.publish(util_msg)

            memory_msg = Float32()
            memory_msg.data = gpu_memory
            self.gpu_memory_pub.publish(memory_msg)

        except Exception as e:
            self.get_logger().warn(f'GPU monitoring failed: {e}')

    def get_gpu_utilization(self):
        """Get GPU utilization percentage"""
        # This would interface with NVIDIA management library
        # For demonstration, return simulated value
        return 45.0

    def get_gpu_memory_usage(self):
        """Get GPU memory usage percentage"""
        # This would interface with NVIDIA management library
        # For demonstration, return simulated value
        return 60.0

    def acquire_gpu_resources(self):
        """Acquire GPU resources for planning"""
        with self.gpu_lock:
            if self.active_planners < self.max_planners:
                self.active_planners += 1
                return True
            else:
                return False

    def release_gpu_resources(self):
        """Release GPU resources after planning"""
        with self.gpu_lock:
            if self.active_planners > 0:
                self.active_planners -= 1

class OptimizedIsaacNav2Planner(Node):
    def __init__(self):
        super().__init__('optimized_isaac_nav2_planner')

        # Initialize GPU resource manager
        self.gpu_manager = GPUResourceManager()

        # Subscribe to navigation requests
        self.goal_sub = self.create_subscription(
            PoseStamped, '/goal_pose', self.optimized_goal_callback, 10)

        # Publisher for planned paths
        self.path_pub = self.create_publisher(Path, '/plan', 10)

    def optimized_goal_callback(self, msg):
        """Handle navigation goal with resource optimization"""
        # Try to acquire GPU resources
        if self.gpu_manager.acquire_gpu_resources():
            try:
                # Perform GPU-accelerated path planning
                self.gpu_path_planning(msg)
            finally:
                # Always release resources
                self.gpu_manager.release_gpu_resources()
        else:
            # Fallback to CPU planning if GPU resources unavailable
            self.cpu_path_planning(msg)

    def gpu_path_planning(self, goal_msg):
        """GPU-accelerated path planning with resource management"""
        self.get_logger().info('Using GPU for path planning')

        # Check GPU availability
        if not cp.cuda.is_available():
            self.get_logger().warn('GPU not available, using CPU fallback')
            self.cpu_path_planning(goal_msg)
            return

        # Perform GPU-accelerated planning
        # This would use the GPU-accelerated planners implemented earlier
        pass

    def cpu_path_planning(self, goal_msg):
        """CPU-based path planning (fallback)"""
        self.get_logger().info('Using CPU for path planning')

        # Perform CPU-based planning
        # This would use traditional path planning algorithms
        pass
```

## Best Practices for Nav2 with Isaac

### 1. Configuration Optimization
- Tune costmap parameters for humanoid size and dynamics
- Adjust inflation radius based on robot dimensions
- Configure appropriate sensor fusion for humanoid perception
- Set realistic velocity and acceleration limits

### 2. Performance Considerations
- Use GPU acceleration for computationally intensive tasks
- Implement proper resource management
- Monitor system performance during navigation
- Optimize map resolution for your use case

### 3. Safety and Reliability
- Implement proper recovery behaviors
- Use appropriate safety margins in costmaps
- Monitor robot balance during navigation
- Implement emergency stop capabilities

### 4. Testing and Validation
- Test navigation in simulation before real deployment
- Validate path planning in various environments
- Test edge cases and failure scenarios
- Monitor navigation performance metrics

## Troubleshooting Common Issues

### Path Planning Problems
- Check costmap configuration and inflation parameters
- Verify sensor data quality and frequency
- Ensure proper TF tree configuration
- Validate map quality and resolution

### Performance Issues
- Monitor GPU utilization and memory usage
- Check for CPU bottlenecks in sensor processing
- Verify adequate update frequencies
- Profile navigation components for optimization

### Navigation Failures
- Review recovery behavior configuration
- Check obstacle detection and costmap updates
- Validate localization accuracy
- Verify robot kinematic constraints

## Summary

Nav2 provides a robust and flexible navigation framework that, when integrated with Isaac's GPU acceleration capabilities, offers powerful path planning and navigation for humanoid robots. The combination enables real-time processing of complex navigation tasks while maintaining the flexibility and reliability required for autonomous humanoid navigation.

Key aspects of Nav2 with Isaac integration include:
- GPU-accelerated path planning algorithms for improved performance
- Humanoid-specific navigation constraints and behaviors
- Advanced behavior tree integration for complex navigation tasks
- Resource management for optimal GPU utilization

The successful implementation of Nav2 with Isaac requires careful configuration of both the navigation parameters and the GPU acceleration components, ensuring that the system is optimized for the specific requirements of humanoid robot navigation.

In the next chapter, we'll explore reinforcement learning and sim-to-real transfer techniques in the context of Isaac, examining how these approaches can be applied to humanoid robot control and learning.